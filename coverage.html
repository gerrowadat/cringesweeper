
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gerrowadat/cringesweeper/cmd/auth.go (18.0%)</option>
				
				<option value="file1">github.com/gerrowadat/cringesweeper/cmd/ls.go (16.3%)</option>
				
				<option value="file2">github.com/gerrowadat/cringesweeper/cmd/prune.go (24.9%)</option>
				
				<option value="file3">github.com/gerrowadat/cringesweeper/cmd/root.go (33.3%)</option>
				
				<option value="file4">github.com/gerrowadat/cringesweeper/cmd/server.go (7.3%)</option>
				
				<option value="file5">github.com/gerrowadat/cringesweeper/cmd/version.go (20.0%)</option>
				
				<option value="file6">github.com/gerrowadat/cringesweeper/cringesweeper.go (0.0%)</option>
				
				<option value="file7">github.com/gerrowadat/cringesweeper/internal/auth.go (85.2%)</option>
				
				<option value="file8">github.com/gerrowadat/cringesweeper/internal/bsky.go (15.6%)</option>
				
				<option value="file9">github.com/gerrowadat/cringesweeper/internal/credentials.go (34.1%)</option>
				
				<option value="file10">github.com/gerrowadat/cringesweeper/internal/logger.go (36.1%)</option>
				
				<option value="file11">github.com/gerrowadat/cringesweeper/internal/mastodon.go (29.2%)</option>
				
				<option value="file12">github.com/gerrowadat/cringesweeper/internal/social.go (12.4%)</option>
				
				<option value="file13">github.com/gerrowadat/cringesweeper/internal/version.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/gerrowadat/cringesweeper/internal"
        "github.com/spf13/cobra"
)

var authCmd = &amp;cobra.Command{
        Use:   "auth",
        Short: "Setup authentication for social media platforms",
        Long: `Interactive setup of authentication credentials for social media platforms.

Use --platforms to set up authentication for multiple platforms (e.g., --platforms=bluesky,mastodon
or --platforms=all). When multiple platforms are specified, authentication setup
is performed sequentially for each platform with clear progress indicators.

Guides you through obtaining the necessary API keys, app passwords, and access 
tokens required for authenticated operations like post deletion. Provides 
step-by-step instructions and URLs for each platform's authentication process.

Supports credential storage both as environment variables and in local config files.`,
        Args: cobra.NoArgs,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                platformsStr, _ := cmd.Flags().GetString("platforms")
                status, _ := cmd.Flags().GetBool("status")

                // Handle status flag - always show all platforms when --status is used
                if status </span><span class="cov0" title="0">{
                        showCredentialStatus("all")
                        return
                }</span>

                // Determine which platforms to use
                <span class="cov0" title="0">var platforms []string
                var err error
                
                if platformsStr == "" </span><span class="cov0" title="0">{
                        fmt.Printf("Error: --platforms flag is required. Specify comma-separated platforms (bluesky,mastodon) or 'all'\n")
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">platforms, err = internal.ParsePlatforms(platformsStr)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %v\n", err)
                        os.Exit(1)
                }</span>

                // Process each platform sequentially (auth is interactive)
                <span class="cov0" title="0">successCount := 0
                for i, platformName := range platforms </span><span class="cov0" title="0">{
                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                fmt.Printf("\n=== SETTING UP %s ===\n", strings.ToUpper(platformName))
                        }</span>

                        <span class="cov0" title="0">client, exists := internal.GetClient(platformName)
                        if !exists </span><span class="cov0" title="0">{
                                fmt.Printf("Error: Unsupported platform '%s'. Supported platforms: %s\n", 
                                        platformName, strings.Join(internal.GetAllPlatformNames(), ", "))
                                if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                        fmt.Printf("Skipping %s and continuing with other platforms...\n", platformName)
                                        continue</span>
                                }
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("Setting up authentication for %s\n\n", client.GetPlatformName())

                        var authErr error
                        switch platformName </span>{
                        case "bluesky":<span class="cov0" title="0">
                                authErr = setupBlueskyAuth()</span>
                        case "mastodon":<span class="cov0" title="0">
                                authErr = setupMastodonAuth()</span>
                        default:<span class="cov0" title="0">
                                authErr = fmt.Errorf("authentication not implemented for platform: %s", platformName)</span>
                        }

                        <span class="cov0" title="0">if authErr != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error setting up authentication for %s: %v\n", platformName, authErr)
                                if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                        fmt.Printf("Skipping %s and continuing with other platforms...\n", platformName)
                                        continue</span>
                                }
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("\n‚úÖ Authentication setup complete for %s!\n", client.GetPlatformName())
                        successCount++

                        // Add spacing between platforms when processing multiple
                        if len(platforms) &gt; 1 &amp;&amp; i &lt; len(platforms)-1 </span><span class="cov0" title="0">{
                                fmt.Println() // Extra newline between platforms
                        }</span>
                }

                // Summary message
                <span class="cov0" title="0">if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                        fmt.Printf("\n=== AUTHENTICATION SUMMARY ===\n")
                        fmt.Printf("Successfully set up authentication for %d out of %d platforms.\n", successCount, len(platforms))
                }</span>
                <span class="cov0" title="0">fmt.Println("You can now use commands that require authentication.")
                fmt.Println()
                fmt.Println("üí° Tip: Use 'cringesweeper auth --status' to view your saved credentials.")</span>
        },
}

func setupBlueskyAuth() error <span class="cov0" title="0">{
        fmt.Println("üîê Bluesky Authentication Setup")
        fmt.Println("===============================")
        fmt.Println()
        fmt.Println("Bluesky uses app passwords for API access.")
        fmt.Println("You'll need to create an app password in your Bluesky settings.")
        fmt.Println()

        fmt.Println("Steps to create an app password:")
        fmt.Println("1. Go to https://bsky.app/settings/app-passwords")
        fmt.Println("2. Log in to your Bluesky account")
        fmt.Println("3. Click 'Add App Password'")
        fmt.Println("4. Give it a name (e.g., 'CringeSweeper')")
        fmt.Println("5. Copy the generated app password")
        fmt.Println()

        // Get username
        fmt.Print("Enter your Bluesky username (e.g., user.bsky.social): ")
        username := strings.TrimSpace(readInput())
        if username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("username is required")
        }</span>

        // Get app password
        <span class="cov0" title="0">fmt.Print("Enter your app password: ")
        appPassword := strings.TrimSpace(readInput())
        if appPassword == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app password is required")
        }</span>

        // Store credentials
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("Setting environment variables...")
        fmt.Printf("export BLUESKY_USER=\"%s\"\n", username)
        fmt.Printf("export BLUESKY_PASSWORD=\"%s\"\n", appPassword)
        fmt.Println()

        // Optionally save to config file
        fmt.Print("Would you like to save these credentials to ~/.config/cringesweeper? (y/n): ")
        if askYesNo() </span><span class="cov0" title="0">{
                authManager, err := internal.NewAuthManager()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Could not create auth manager: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        creds := &amp;internal.Credentials{
                                Platform:    "bluesky",
                                Username:    username,
                                AppPassword: appPassword,
                        }
                        if err := authManager.SaveCredentials(creds); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: Could not save credentials: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("‚úÖ Credentials saved to ~/.config/cringesweeper/bluesky.json")
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Println("üí° Add the export commands to your shell profile (.bashrc, .zshrc, etc.) to persist them.")

        return nil</span>
}

func setupMastodonAuth() error <span class="cov0" title="0">{
        fmt.Println("üîê Mastodon Authentication Setup")
        fmt.Println("================================")
        fmt.Println()
        fmt.Println("Mastodon uses OAuth2 for authentication.")
        fmt.Println("You'll need to register an application on your Mastodon instance.")
        fmt.Println()

        // Get instance
        fmt.Print("Enter your Mastodon instance (e.g., mastodon.social): ")
        instance := strings.TrimSpace(readInput())
        if instance == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("instance is required")
        }</span>

        // Add https:// if not present
        <span class="cov0" title="0">if !strings.HasPrefix(instance, "http") </span><span class="cov0" title="0">{
                instance = "https://" + instance
        }</span>

        <span class="cov0" title="0">instanceURL := instance
        settingsURL := fmt.Sprintf("%s/settings/applications", instanceURL)

        fmt.Printf("Instance: %s\n", instanceURL)
        fmt.Println()

        fmt.Println("Steps to create an application:")
        fmt.Printf("1. Go to %s\n", settingsURL)
        fmt.Println("2. Log in to your Mastodon account")
        fmt.Println("3. Click 'New Application'")
        fmt.Println("4. Fill in the application details:")
        fmt.Println("   - Application name: CringeSweeper")
        fmt.Println("   - Application website: https://github.com/gerrowadat/cringesweeper")
        fmt.Println("   - Redirect URI: urn:ietf:wg:oauth:2.0:oob")
        fmt.Println("5. Required scopes: read, write")
        fmt.Println("6. Click 'Submit'")
        fmt.Println("7. Copy the access token from the application details")
        fmt.Println()

        // Get username
        fmt.Print("Enter your Mastodon username (without @): ")
        username := strings.TrimSpace(readInput())
        if username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("username is required")
        }</span>

        // Get access token
        <span class="cov0" title="0">fmt.Print("Enter your access token: ")
        accessToken := strings.TrimSpace(readInput())
        if accessToken == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("access token is required")
        }</span>

        // Store credentials
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("Setting environment variables...")
        fullUsername := fmt.Sprintf("%s@%s", username, strings.TrimPrefix(instanceURL, "https://"))
        fmt.Printf("export MASTODON_USER=\"%s\"\n", fullUsername)
        fmt.Printf("export MASTODON_INSTANCE=\"%s\"\n", instanceURL)
        fmt.Printf("export MASTODON_ACCESS_TOKEN=\"%s\"\n", accessToken)
        fmt.Println()

        // Optionally save to config file
        fmt.Print("Would you like to save these credentials to ~/.config/cringesweeper? (y/n): ")
        if askYesNo() </span><span class="cov0" title="0">{
                authManager, err := internal.NewAuthManager()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Could not create auth manager: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        creds := &amp;internal.Credentials{
                                Platform:    "mastodon",
                                Username:    fullUsername,
                                Instance:    instanceURL,
                                AccessToken: accessToken,
                        }
                        if err := authManager.SaveCredentials(creds); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: Could not save credentials: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("‚úÖ Credentials saved to ~/.config/cringesweeper/mastodon.json")
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Println("üí° Add the export commands to your shell profile (.bashrc, .zshrc, etc.) to persist them.")

        return nil</span>
}

func askYesNo() bool <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov0" title="0">{
                input, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">input = strings.ToLower(strings.TrimSpace(input))
                switch input </span>{
                case "y", "yes":<span class="cov0" title="0">
                        return true</span>
                case "n", "no":<span class="cov0" title="0">
                        return false</span>
                default:<span class="cov0" title="0">
                        fmt.Print("Please enter 'y' or 'n': ")</span>
                }
        }
}

func readInput() string <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        input, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(input)</span>
}

func showCredentialStatus(platform string) <span class="cov8" title="1">{
        if platform != "all" </span><span class="cov8" title="1">{
                // Show status for specific platform
                showPlatformStatus(platform)
                return
        }</span>

        // Show status for all supported platforms
        <span class="cov8" title="1">fmt.Println("üìã Credential Status Summary")
        fmt.Println("============================")
        fmt.Println()

        // Get all supported platforms from the internal registry
        supportedPlatforms := []string{"bluesky", "mastodon"}

        for i, p := range supportedPlatforms </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Println()
                }</span>
                <span class="cov8" title="1">showPlatformStatus(p)</span>
        }
}

func showPlatformStatus(platform string) <span class="cov8" title="1">{
        fmt.Printf("Platform: %s\n", platform)
        fmt.Printf("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ%s\n", strings.Repeat("‚îÄ", len(platform)))

        // Check saved credentials
        authManager, err := internal.NewAuthManager()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Error accessing credential storage: %v\n", err)
                return
        }</span>

        <span class="cov8" title="1">creds, err := authManager.LoadCredentials(platform)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("‚ùå No saved credentials found\n")
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("‚úÖ Saved credentials found\n")
                fmt.Printf("   Username: %s\n", creds.Username)
                if creds.Instance != "" </span><span class="cov8" title="1">{
                        fmt.Printf("   Instance: %s\n", creds.Instance)
                }</span>

                // Validate credentials
                <span class="cov8" title="1">if err := internal.ValidateCredentials(creds); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Credentials incomplete: %v\n", err)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("‚úÖ Credentials complete and valid\n")
                }</span>
        }

        // Check environment variables
        <span class="cov8" title="1">envCreds := internal.GetCredentialsFromEnv(platform)
        if envCreds != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ Environment variables found\n")
                if err := internal.ValidateCredentials(envCreds); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Environment credentials incomplete: %v\n", err)
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Printf("‚ùå No environment variables found\n")
        }</span>

        // Show what credentials would be used
        <span class="cov8" title="1">finalCreds, err := internal.GetCredentialsForPlatform(platform)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("‚ùå No usable credentials available\n")
                fmt.Printf("   Run 'cringesweeper auth --platforms=%s' to set up authentication\n", platform)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("üéØ Active credentials: %s\n", finalCreds.Username)
        }</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(authCmd)
        authCmd.Flags().String("platforms", "", "Comma-separated list of platforms (bluesky,mastodon) or 'all' for all platforms")
        authCmd.Flags().Bool("status", false, "Show credential status instead of setting up authentication")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/gerrowadat/cringesweeper/internal"
        "github.com/spf13/cobra"
)

var lsCmd = &amp;cobra.Command{
        Use:   "ls [username]",
        Short: "List recent posts from social media timelines",
        Long: `List and display posts from a user's social media timeline.

Supports multiple platforms including Bluesky and Mastodon. Shows post content,
timestamps, author information, and post types (original, repost, reply, etc.).

Use --platforms to specify multiple platforms (e.g., --platforms=bluesky,mastodon
or --platforms=all). When multiple platforms are specified, results are shown
grouped by platform with clear headers.

By default, shows recent posts (typically 10 most recent). Use --continue to
keep searching further back in time until no more posts are found. Use age
filters like --max-post-age or --before-date to limit results to specific
time periods.

The username can be provided as an argument or via environment variables.`,
        Args: cobra.MaximumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                platformsStr, _ := cmd.Flags().GetString("platforms")
                continueUntilEnd, _ := cmd.Flags().GetBool("continue")
                limitStr, _ := cmd.Flags().GetString("limit")
                maxAgeStr, _ := cmd.Flags().GetString("max-post-age")
                beforeDateStr, _ := cmd.Flags().GetString("before-date")

                // Determine which platforms to use
                var platforms []string
                var err error
                
                if platformsStr == "" </span><span class="cov0" title="0">{
                        fmt.Printf("Error: --platforms flag is required. Specify comma-separated platforms (bluesky,mastodon) or 'all'\n")
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">platforms, err = internal.ParsePlatforms(platformsStr)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %v\n", err)
                        os.Exit(1)
                }</span>

                // Get username with fallback priority: argument &gt; saved credentials &gt; environment
                <span class="cov0" title="0">argUsername := ""
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        argUsername = args[0]
                }</span>

                // Process each platform
                <span class="cov0" title="0">for i, platformName := range platforms </span><span class="cov0" title="0">{
                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                fmt.Printf("\n=== %s ===\n", strings.ToUpper(platformName))
                        }</span>

                        <span class="cov0" title="0">username, err := internal.GetUsernameForPlatform(platformName, argUsername)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error for %s: %v\n", platformName, err)
                                if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                        continue</span> // Skip this platform but continue with others
                                }
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }

                        <span class="cov0" title="0">client, exists := internal.GetClient(platformName)
                        if !exists </span><span class="cov0" title="0">{
                                fmt.Printf("Error: Unsupported platform '%s'. Supported platforms: %s\n", 
                                        platformName, strings.Join(internal.GetAllPlatformNames(), ", "))
                                if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                        continue</span> // Skip this platform but continue with others
                                }
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }

                        // Parse limit
                        <span class="cov0" title="0">limit := 10 // default
                        if limitStr != "" </span><span class="cov0" title="0">{
                                parsedLimit, err := strconv.Atoi(limitStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error parsing limit for %s: %v\n", platformName, err)
                                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">os.Exit(1)</span>
                                }
                                <span class="cov0" title="0">if parsedLimit &lt;= 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("Error: limit must be a positive number\n")
                                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">os.Exit(1)</span>
                                }
                                <span class="cov0" title="0">limit = parsedLimit</span>
                        }

                        // Parse age filters
                        <span class="cov0" title="0">var maxAge *time.Duration
                        var beforeDate *time.Time

                        if maxAgeStr != "" </span><span class="cov0" title="0">{
                                duration, err := parseDuration(maxAgeStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error parsing max-post-age for %s: %v\n", platformName, err)
                                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">os.Exit(1)</span>
                                }
                                <span class="cov0" title="0">maxAge = &amp;duration</span>
                        }

                        <span class="cov0" title="0">if beforeDateStr != "" </span><span class="cov0" title="0">{
                                date, err := parseDate(beforeDateStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error parsing before-date for %s: %v\n", platformName, err)
                                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">os.Exit(1)</span>
                                }
                                <span class="cov0" title="0">beforeDate = &amp;date</span>
                        }

                        // Perform listing
                        <span class="cov0" title="0">if continueUntilEnd </span><span class="cov0" title="0">{
                                performContinuousListing(client, username, limit, maxAge, beforeDate)
                        }</span> else<span class="cov0" title="0"> {
                                performSingleListing(client, username, limit, maxAge, beforeDate)
                        }</span>

                        // Add spacing between platforms when processing multiple
                        <span class="cov0" title="0">if len(platforms) &gt; 1 &amp;&amp; i &lt; len(platforms)-1 </span><span class="cov0" title="0">{
                                fmt.Println() // Extra newline between platforms
                        }</span>
                }
        },
}

func performSingleListing(client internal.SocialClient, username string, limit int, maxAge *time.Duration, beforeDate *time.Time) <span class="cov0" title="0">{
        posts, err := client.FetchUserPosts(username, limit)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error fetching posts from %s: %v\n", client.GetPlatformName(), err)
                os.Exit(1)
        }</span>

        // Filter posts by age criteria if specified
        <span class="cov0" title="0">filteredPosts := filterPostsByAge(posts, maxAge, beforeDate)
        
        if len(filteredPosts) == 0 </span><span class="cov0" title="0">{
                if maxAge != nil || beforeDate != nil </span><span class="cov0" title="0">{
                        fmt.Println("No posts match the specified age criteria")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("No posts found")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">fmt.Printf("Posts from %s", client.GetPlatformName())
        if maxAge != nil || beforeDate != nil </span><span class="cov0" title="0">{
                fmt.Printf(" (filtered by age criteria)")
        }</span>
        <span class="cov0" title="0">fmt.Printf(":\n\n")

        displayPostsStreaming(filteredPosts)</span>
}

func performContinuousListing(client internal.SocialClient, username string, batchLimit int, maxAge *time.Duration, beforeDate *time.Time) <span class="cov0" title="0">{
        platform := client.GetPlatformName()
        round := 1
        totalDisplayed := 0
        headerShown := false
        cursor := "" // Start with empty cursor

        fmt.Printf("Searching %s for posts", platform)
        if maxAge != nil || beforeDate != nil </span><span class="cov0" title="0">{
                fmt.Printf(" matching age criteria")
        }</span>
        <span class="cov0" title="0">fmt.Printf(" (will continue until no more posts found)...\n\n")

        for </span><span class="cov0" title="0">{
                posts, nextCursor, err := client.FetchUserPostsPaginated(username, batchLimit, cursor)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error in round %d: %v\n", round, err)
                        break</span>
                }

                // Filter posts by age criteria if specified
                <span class="cov0" title="0">filteredPosts, shouldContinue := filterPostsByAgeWithTermination(posts, maxAge, beforeDate)

                if len(filteredPosts) == 0 &amp;&amp; len(posts) == 0 </span><span class="cov0" title="0">{
                        if round == 1 </span><span class="cov0" title="0">{
                                fmt.Println("No posts found")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("\nNo more posts found. Search complete after %d rounds.\n", round)
                                fmt.Printf("Total posts displayed: %d\n", totalDisplayed)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // If we shouldn't continue due to age threshold, stop here
                <span class="cov0" title="0">if !shouldContinue </span><span class="cov0" title="0">{
                        // Show any remaining filtered posts first
                        if len(filteredPosts) &gt; 0 </span><span class="cov0" title="0">{
                                // Show header on first batch with results
                                if !headerShown </span><span class="cov0" title="0">{
                                        fmt.Printf("Posts from %s:\n\n", platform)
                                        headerShown = true
                                }</span>
                                // Stream the posts immediately
                                <span class="cov0" title="0">for _, post := range filteredPosts </span><span class="cov0" title="0">{
                                        displaySinglePost(post, totalDisplayed+1)
                                        totalDisplayed++
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("\nReached age threshold. All matching posts have been displayed after %d rounds.\n", round)
                        fmt.Printf("Total posts displayed: %d\n", totalDisplayed)
                        break</span>
                }

                // If we got posts but none match filters, continue to next page
                <span class="cov0" title="0">if len(filteredPosts) == 0 &amp;&amp; len(posts) &gt; 0 </span><span class="cov0" title="0">{
                        // Check if we have a next cursor to continue
                        if nextCursor == "" || nextCursor == cursor </span><span class="cov0" title="0">{
                                fmt.Printf("\nReached end of timeline. No more posts match criteria after %d rounds.\n", round)
                                fmt.Printf("Total posts displayed: %d\n", totalDisplayed)
                                break</span>
                        }
                        <span class="cov0" title="0">cursor = nextCursor
                        round++
                        time.Sleep(time.Second)
                        continue</span>
                }

                // Show header on first batch with results
                <span class="cov0" title="0">if !headerShown </span><span class="cov0" title="0">{
                        fmt.Printf("Posts from %s:\n\n", platform)
                        headerShown = true
                }</span>

                // Stream the posts immediately
                <span class="cov0" title="0">for _, post := range filteredPosts </span><span class="cov0" title="0">{
                        displaySinglePost(post, totalDisplayed+1)
                        totalDisplayed++
                }</span>

                // Check if we have a next cursor to continue
                <span class="cov0" title="0">if nextCursor == "" || nextCursor == cursor </span><span class="cov0" title="0">{
                        fmt.Printf("\nReached end of timeline. Search complete after %d rounds.\n", round)
                        fmt.Printf("Total posts displayed: %d\n", totalDisplayed)
                        break</span>
                }

                <span class="cov0" title="0">cursor = nextCursor
                round++

                // Small delay between rounds to be respectful to APIs
                time.Sleep(time.Second)</span>
        }
}

func filterPostsByAge(posts []internal.Post, maxAge *time.Duration, beforeDate *time.Time) []internal.Post <span class="cov0" title="0">{
        if maxAge == nil &amp;&amp; beforeDate == nil </span><span class="cov0" title="0">{
                return posts
        }</span>

        <span class="cov0" title="0">var filtered []internal.Post
        now := time.Now()

        for _, post := range posts </span><span class="cov0" title="0">{
                shouldInclude := true

                // Check max age criteria
                if maxAge != nil </span><span class="cov0" title="0">{
                        if now.Sub(post.CreatedAt) &gt; *maxAge </span><span class="cov0" title="0">{
                                shouldInclude = false
                        }</span>
                }

                // Check before date criteria
                <span class="cov0" title="0">if beforeDate != nil </span><span class="cov0" title="0">{
                        if !post.CreatedAt.Before(*beforeDate) </span><span class="cov0" title="0">{
                                shouldInclude = false
                        }</span>
                }

                <span class="cov0" title="0">if shouldInclude </span><span class="cov0" title="0">{
                        filtered = append(filtered, post)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// filterPostsByAgeWithTermination filters posts and returns whether we should continue fetching
// Returns (filteredPosts, shouldContinue)
func filterPostsByAgeWithTermination(posts []internal.Post, maxAge *time.Duration, beforeDate *time.Time) ([]internal.Post, bool) <span class="cov0" title="0">{
        // If no age criteria, return all posts and continue
        if maxAge == nil &amp;&amp; beforeDate == nil </span><span class="cov0" title="0">{
                return posts, true
        }</span>

        <span class="cov0" title="0">var filtered []internal.Post
        now := time.Now()
        shouldContinue := true

        for _, post := range posts </span><span class="cov0" title="0">{
                shouldInclude := true
                postTooOld := false

                // Check max age criteria
                if maxAge != nil </span><span class="cov0" title="0">{
                        if now.Sub(post.CreatedAt) &gt; *maxAge </span><span class="cov0" title="0">{
                                shouldInclude = false
                                postTooOld = true
                        }</span>
                }

                // Check before date criteria
                <span class="cov0" title="0">if beforeDate != nil </span><span class="cov0" title="0">{
                        if !post.CreatedAt.Before(*beforeDate) </span><span class="cov0" title="0">{
                                shouldInclude = false
                                postTooOld = true
                        }</span>
                }

                <span class="cov0" title="0">if shouldInclude </span><span class="cov0" title="0">{
                        filtered = append(filtered, post)
                }</span> else<span class="cov0" title="0"> if postTooOld </span><span class="cov0" title="0">{
                        // If we encounter a post that's too old, we should stop fetching
                        // since posts are typically ordered chronologically (newest first)
                        shouldContinue = false
                        break</span>
                }
        }

        <span class="cov0" title="0">return filtered, shouldContinue</span>
}

func displayPostsStreaming(posts []internal.Post) <span class="cov0" title="0">{
        for i, post := range posts </span><span class="cov0" title="0">{
                displaySinglePost(post, i+1)
        }</span>
}

func displaySinglePost(post internal.Post, index int) <span class="cov0" title="0">{
        fmt.Printf("Post %d", index)

        // Show post type indicator
        switch post.Type </span>{
        case internal.PostTypeRepost:<span class="cov0" title="0">
                fmt.Printf(" [REPOST]")</span>
        case internal.PostTypeReply:<span class="cov0" title="0">
                fmt.Printf(" [REPLY]")</span>
        case internal.PostTypeQuote:<span class="cov0" title="0">
                fmt.Printf(" [QUOTE]")</span>
        case internal.PostTypeLike:<span class="cov0" title="0">
                fmt.Printf(" [LIKE]")</span>
        }
        <span class="cov0" title="0">fmt.Printf(":\n")

        fmt.Printf("  Author: @%s", post.Handle)
        if post.Author != "" &amp;&amp; post.Author != post.Handle </span><span class="cov0" title="0">{
                fmt.Printf(" (%s)", post.Author)
        }</span>
        <span class="cov0" title="0">fmt.Printf("\n")

        fmt.Printf("  Posted: %s\n", post.CreatedAt.Format("2006-01-02 15:04:05"))

        // Handle reposts specially
        if post.Type == internal.PostTypeRepost &amp;&amp; post.OriginalPost != nil </span><span class="cov0" title="0">{
                fmt.Printf("  Reposted from: @%s", post.OriginalHandle)
                if post.OriginalAuthor != "" &amp;&amp; post.OriginalAuthor != post.OriginalHandle </span><span class="cov0" title="0">{
                        fmt.Printf(" (%s)", post.OriginalAuthor)
                }</span>
                <span class="cov0" title="0">fmt.Printf("\n")
                fmt.Printf("  Original content: %s\n", post.OriginalPost.Content)</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("  Content: %s\n", post.Content)
        }</span>

        // Show engagement metrics if available
        <span class="cov0" title="0">if post.LikeCount &gt; 0 || post.RepostCount &gt; 0 || post.ReplyCount &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Engagement: ")
                var metrics []string
                if post.LikeCount &gt; 0 </span><span class="cov0" title="0">{
                        metrics = append(metrics, fmt.Sprintf("%d likes", post.LikeCount))
                }</span>
                <span class="cov0" title="0">if post.RepostCount &gt; 0 </span><span class="cov0" title="0">{
                        metrics = append(metrics, fmt.Sprintf("%d reposts", post.RepostCount))
                }</span>
                <span class="cov0" title="0">if post.ReplyCount &gt; 0 </span><span class="cov0" title="0">{
                        metrics = append(metrics, fmt.Sprintf("%d replies", post.ReplyCount))
                }</span>
                <span class="cov0" title="0">fmt.Printf("%s\n", fmt.Sprintf("%v", metrics))</span>
        }

        <span class="cov0" title="0">if post.URL != "" </span><span class="cov0" title="0">{
                fmt.Printf("  URL: %s\n", post.URL)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

func displayPosts(posts []internal.Post, platform string) <span class="cov8" title="1">{
        if len(posts) == 0 </span><span class="cov8" title="1">{
                fmt.Println("No posts found")
                return
        }</span>

        <span class="cov8" title="1">fmt.Printf("Recent posts from %s:\n\n", platform)

        for i, post := range posts </span><span class="cov8" title="1">{
                fmt.Printf("Post %d", i+1)

                // Show post type indicator
                switch post.Type </span>{
                case internal.PostTypeRepost:<span class="cov8" title="1">
                        fmt.Printf(" [REPOST]")</span>
                case internal.PostTypeReply:<span class="cov8" title="1">
                        fmt.Printf(" [REPLY]")</span>
                case internal.PostTypeQuote:<span class="cov8" title="1">
                        fmt.Printf(" [QUOTE]")</span>
                case internal.PostTypeLike:<span class="cov8" title="1">
                        fmt.Printf(" [LIKE]")</span>
                }
                <span class="cov8" title="1">fmt.Printf(":\n")

                fmt.Printf("  Author: @%s", post.Handle)
                if post.Author != "" &amp;&amp; post.Author != post.Handle </span><span class="cov8" title="1">{
                        fmt.Printf(" (%s)", post.Author)
                }</span>
                <span class="cov8" title="1">fmt.Printf("\n")

                fmt.Printf("  Posted: %s\n", post.CreatedAt.Format("2006-01-02 15:04:05"))

                // Handle reposts specially
                if post.Type == internal.PostTypeRepost &amp;&amp; post.OriginalPost != nil </span><span class="cov8" title="1">{
                        fmt.Printf("  Reposted from: @%s", post.OriginalHandle)
                        if post.OriginalAuthor != "" &amp;&amp; post.OriginalAuthor != post.OriginalHandle </span><span class="cov8" title="1">{
                                fmt.Printf(" (%s)", post.OriginalAuthor)
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("\n")
                        fmt.Printf("  Original content: %s\n", post.OriginalPost.Content)</span>
                } else<span class="cov8" title="1"> {
                        fmt.Printf("  Content: %s\n", post.Content)
                }</span>

                // Show engagement metrics if available
                <span class="cov8" title="1">if post.LikeCount &gt; 0 || post.RepostCount &gt; 0 || post.ReplyCount &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("  Engagement: ")
                        var metrics []string
                        if post.LikeCount &gt; 0 </span><span class="cov8" title="1">{
                                metrics = append(metrics, fmt.Sprintf("%d likes", post.LikeCount))
                        }</span>
                        <span class="cov8" title="1">if post.RepostCount &gt; 0 </span><span class="cov0" title="0">{
                                metrics = append(metrics, fmt.Sprintf("%d reposts", post.RepostCount))
                        }</span>
                        <span class="cov8" title="1">if post.ReplyCount &gt; 0 </span><span class="cov0" title="0">{
                                metrics = append(metrics, fmt.Sprintf("%d replies", post.ReplyCount))
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("%s\n", fmt.Sprintf("%v", metrics))</span>
                }

                <span class="cov8" title="1">if post.URL != "" </span><span class="cov8" title="1">{
                        fmt.Printf("  URL: %s\n", post.URL)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(lsCmd)
        lsCmd.Flags().String("platforms", "", "Comma-separated list of platforms (bluesky,mastodon) or 'all' for all platforms")
        lsCmd.Flags().String("limit", "10", "Maximum number of posts to fetch per batch")
        lsCmd.Flags().String("max-post-age", "", "Only show posts older than this (e.g., 30d, 1y, 24h)")
        lsCmd.Flags().String("before-date", "", "Only show posts created before this date (YYYY-MM-DD or MM/DD/YYYY)")
        lsCmd.Flags().Bool("continue", false, "Continue searching and fetching posts until no more are found")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/gerrowadat/cringesweeper/internal"
        "github.com/spf13/cobra"
)

var pruneCmd = &amp;cobra.Command{
        Use:   "prune [username]",
        Short: "Delete posts based on age, date, and preservation rules",
        Long: `Delete posts, unlike posts, and unshare reposts from your social media accounts based on configurable criteria.

Use --platforms to operate on multiple platforms simultaneously (e.g., --platforms=bluesky,mastodon
or --platforms=all). When multiple platforms are specified, operations are performed
on each platform sequentially with clear progress indicators.

What gets processed:
- Original posts you created: Deleted permanently
- Posts you've reposted: Removes your repost (unrepost)
- Posts you've liked: Removes your like (unlike) - only when --unlike-posts is used

Posts can be processed by maximum age (e.g., older than 30 days) or before a specific 
date. Smart preservation rules protect important content like pinned posts and 
posts you've liked.

By default, only processes recent posts (typically 100 most recent). Use --continue 
to keep searching further back in time until no more posts match your criteria.

ALWAYS use --dry-run first to preview what would be processed. Actions are 
permanent and cannot be undone. Requires authentication for the target platform.`,
        Args: cobra.MaximumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                platformsStr, _ := cmd.Flags().GetString("platforms")
                dryRun, _ := cmd.Flags().GetBool("dry-run")
                preserveSelfLike, _ := cmd.Flags().GetBool("preserve-selflike")
                preservePinned, _ := cmd.Flags().GetBool("preserve-pinned")
                unlikePosts, _ := cmd.Flags().GetBool("unlike-posts")
                unshareReposts, _ := cmd.Flags().GetBool("unshare-reposts")
                continueUntilEnd, _ := cmd.Flags().GetBool("continue")
                maxAgeStr, _ := cmd.Flags().GetString("max-post-age")
                beforeDateStr, _ := cmd.Flags().GetString("before-date")
                rateLimitDelayStr, _ := cmd.Flags().GetString("rate-limit-delay")

                // Determine which platforms to use
                var platforms []string
                var err error
                
                if platformsStr == "" </span><span class="cov0" title="0">{
                        fmt.Printf("Error: --platforms flag is required. Specify comma-separated platforms (bluesky,mastodon) or 'all'\n")
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">platforms, err = internal.ParsePlatforms(platformsStr)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %v\n", err)
                        os.Exit(1)
                }</span>

                // Get username with fallback priority: argument &gt; saved credentials &gt; environment
                <span class="cov0" title="0">argUsername := ""
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        argUsername = args[0]
                }</span>

                // Track overall results across all platforms
                <span class="cov0" title="0">totalResults := &amp;internal.PruneResult{
                        PostsToDelete:  []internal.Post{},
                        PostsToUnlike:  []internal.Post{},
                        PostsToUnshare: []internal.Post{},
                        PostsPreserved: []internal.Post{},
                        DeletedCount:   0,
                        UnlikedCount:   0,
                        UnsharedCount:  0,
                        PreservedCount: 0,
                        ErrorsCount:    0,
                        Errors:         []string{},
                }

                // Process each platform
                for i, platformName := range platforms </span><span class="cov0" title="0">{
                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                fmt.Printf("\n=== PRUNING %s ===\n", strings.ToUpper(platformName))
                        }</span>

                        <span class="cov0" title="0">username, err := internal.GetUsernameForPlatform(platformName, argUsername)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error for %s: %v\n", platformName, err)
                                if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                        totalResults.Errors = append(totalResults.Errors, fmt.Sprintf("%s: %v", platformName, err))
                                        continue</span> // Skip this platform but continue with others
                                }
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }

                        <span class="cov0" title="0">client, exists := internal.GetClient(platformName)
                        if !exists </span><span class="cov0" title="0">{
                                errorMsg := fmt.Sprintf("Unsupported platform '%s'. Supported platforms: %s", 
                                        platformName, strings.Join(internal.GetAllPlatformNames(), ", "))
                                fmt.Printf("Error: %s\n", errorMsg)
                                if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                        totalResults.Errors = append(totalResults.Errors, errorMsg)
                                        continue</span> // Skip this platform but continue with others
                                }
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }

                        // Parse rate limit delay - use platform-appropriate defaults
                        <span class="cov0" title="0">var rateLimitDelay time.Duration
                        if rateLimitDelayStr != "" </span><span class="cov0" title="0">{
                                delay, err := parseDuration(rateLimitDelayStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error parsing rate-limit-delay for %s: %v\n", platformName, err)
                                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                                totalResults.Errors = append(totalResults.Errors, fmt.Sprintf("%s: rate-limit-delay parse error: %v", platformName, err))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">os.Exit(1)</span>
                                }
                                <span class="cov0" title="0">rateLimitDelay = delay</span>
                        } else<span class="cov0" title="0"> {
                                // Set platform-appropriate defaults
                                switch platformName </span>{
                                case "mastodon":<span class="cov0" title="0">
                                        rateLimitDelay = 60 * time.Second</span> // Conservative for Mastodon's 30 DELETEs per 30 minutes
                                case "bluesky":<span class="cov0" title="0">
                                        rateLimitDelay = 1 * time.Second</span> // More permissive for Bluesky's higher limits
                                default:<span class="cov0" title="0">
                                        rateLimitDelay = 5 * time.Second</span> // Safe default for unknown platforms
                                }
                        }

                        // Parse options
                        <span class="cov0" title="0">options := internal.PruneOptions{
                                PreserveSelfLike: preserveSelfLike,
                                PreservePinned:   preservePinned,
                                UnlikePosts:      unlikePosts,
                                UnshareReposts:   unshareReposts,
                                DryRun:           dryRun,
                                RateLimitDelay:   rateLimitDelay,
                        }

                        // Parse max age
                        if maxAgeStr != "" </span><span class="cov0" title="0">{
                                maxAge, err := parseDuration(maxAgeStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error parsing max-post-age for %s: %v\n", platformName, err)
                                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                                totalResults.Errors = append(totalResults.Errors, fmt.Sprintf("%s: max-post-age parse error: %v", platformName, err))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">os.Exit(1)</span>
                                }
                                <span class="cov0" title="0">options.MaxAge = &amp;maxAge</span>
                        }

                        // Parse before date
                        <span class="cov0" title="0">if beforeDateStr != "" </span><span class="cov0" title="0">{
                                beforeDate, err := parseDate(beforeDateStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error parsing before-date for %s: %v\n", platformName, err)
                                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                                totalResults.Errors = append(totalResults.Errors, fmt.Sprintf("%s: before-date parse error: %v", platformName, err))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">os.Exit(1)</span>
                                }
                                <span class="cov0" title="0">options.BeforeDate = &amp;beforeDate</span>
                        }

                        // Validate that at least one criteria is specified
                        <span class="cov0" title="0">if options.MaxAge == nil &amp;&amp; options.BeforeDate == nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error for %s: Must specify either --max-post-age or --before-date\n", platformName)
                                if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                        totalResults.Errors = append(totalResults.Errors, fmt.Sprintf("%s: no age criteria specified", platformName))
                                        continue</span>
                                }
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }

                        // Perform pruning for this platform
                        <span class="cov0" title="0">var result *internal.PruneResult
                        if continueUntilEnd </span><span class="cov0" title="0">{
                                result = performContinuousPruningWithResult(client, username, options)
                        }</span> else<span class="cov0" title="0"> {
                                var err error
                                result, err = client.PrunePosts(username, options)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error pruning posts from %s: %v\n", client.GetPlatformName(), err)
                                        if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                                                totalResults.Errors = append(totalResults.Errors, fmt.Sprintf("%s: %v", platformName, err))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">os.Exit(1)</span>
                                }
                        }

                        // Display results for this platform
                        <span class="cov0" title="0">displayPruneResults(result, client.GetPlatformName(), dryRun)

                        // Add to total results
                        totalResults.PostsToDelete = append(totalResults.PostsToDelete, result.PostsToDelete...)
                        totalResults.PostsToUnlike = append(totalResults.PostsToUnlike, result.PostsToUnlike...)
                        totalResults.PostsToUnshare = append(totalResults.PostsToUnshare, result.PostsToUnshare...)
                        totalResults.PostsPreserved = append(totalResults.PostsPreserved, result.PostsPreserved...)
                        totalResults.DeletedCount += result.DeletedCount
                        totalResults.UnlikedCount += result.UnlikedCount
                        totalResults.UnsharedCount += result.UnsharedCount
                        totalResults.PreservedCount += result.PreservedCount
                        totalResults.ErrorsCount += result.ErrorsCount
                        totalResults.Errors = append(totalResults.Errors, result.Errors...)

                        // Add spacing between platforms when processing multiple
                        if len(platforms) &gt; 1 &amp;&amp; i &lt; len(platforms)-1 </span><span class="cov0" title="0">{
                                fmt.Println() // Extra newline between platforms
                        }</span>
                }

                // Show combined results if multiple platforms were processed
                <span class="cov0" title="0">if len(platforms) &gt; 1 </span><span class="cov0" title="0">{
                        fmt.Printf("\n=== COMBINED RESULTS ===\n")
                        displayPruneResults(totalResults, "All Platforms", dryRun)
                }</span>
        },
}

func performContinuousPruningWithResult(client internal.SocialClient, username string, options internal.PruneOptions) *internal.PruneResult <span class="cov0" title="0">{
        platform := client.GetPlatformName()
        totalDeleted := 0
        totalUnliked := 0
        totalUnshared := 0
        totalPreserved := 0
        totalErrors := 0
        var allErrors []string
        round := 1
        cursor := ""      // Start with empty cursor for pagination
        batchLimit := 100 // Fetch more posts per batch for pruning

        fmt.Printf("Starting continuous pruning on %s (will continue until no more posts match criteria)...\n", platform)
        if options.DryRun </span><span class="cov0" title="0">{
                fmt.Println("DRY RUN MODE: No actual actions will be performed")
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                fmt.Printf("Round %d: Fetching posts...\n", round)
                
                // Use paginated fetching to avoid infinite loops
                posts, nextCursor, err := client.FetchUserPostsPaginated(username, batchLimit, cursor)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error in round %d: %v\n", round, err)
                        fmt.Printf("Stopping continuous pruning. Total processed so far:\n")
                        allErrors = append(allErrors, fmt.Sprintf("Round %d: %v", round, err))
                        break</span>
                }

                // Check if we have reached the end (no more posts or same cursor)
                <span class="cov0" title="0">if len(posts) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Round %d: No more posts found. Pruning complete!\n", round)
                        break</span>
                }

                <span class="cov0" title="0">if nextCursor == "" || nextCursor == cursor </span><span class="cov0" title="0">{
                        fmt.Printf("Round %d: Reached end of timeline. Pruning complete!\n", round)
                        break</span>
                }

                // Create a mock PruneResult to hold posts for this batch and process them
                <span class="cov0" title="0">result := &amp;internal.PruneResult{
                        PostsToDelete:  []internal.Post{},
                        PostsToUnlike:  []internal.Post{},
                        PostsToUnshare: []internal.Post{},
                        PostsPreserved: []internal.Post{},
                        Errors:         []string{},
                }

                // Filter posts by age criteria and process them
                matchingPosts := 0
                for _, post := range posts </span><span class="cov0" title="0">{
                        // Apply age filtering (inline logic)
                        now := time.Now()
                        matchesAge := true
                        
                        if options.MaxAge != nil </span><span class="cov0" title="0">{
                                if now.Sub(post.CreatedAt) &lt;= *options.MaxAge </span><span class="cov0" title="0">{
                                        matchesAge = false
                                }</span>
                        }
                        
                        <span class="cov0" title="0">if options.BeforeDate != nil </span><span class="cov0" title="0">{
                                if !post.CreatedAt.Before(*options.BeforeDate) </span><span class="cov0" title="0">{
                                        matchesAge = false
                                }</span>
                        }
                        
                        <span class="cov0" title="0">if !matchesAge </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">matchingPosts++

                        // Check if post should be preserved (inline logic)
                        shouldPreserve := false
                        if options.PreservePinned &amp;&amp; post.IsPinned </span><span class="cov0" title="0">{
                                shouldPreserve = true
                        }</span>
                        <span class="cov0" title="0">if options.PreserveSelfLike &amp;&amp; post.IsLikedByUser </span><span class="cov0" title="0">{
                                shouldPreserve = true
                        }</span>

                        // Process each matching post
                        <span class="cov0" title="0">if shouldPreserve </span><span class="cov0" title="0">{
                                result.PostsPreserved = append(result.PostsPreserved, post)
                                totalPreserved++
                                if options.DryRun </span><span class="cov0" title="0">{
                                        fmt.Printf("üõ°Ô∏è PRESERVED: %s\n", truncateContent(post.Content, 50))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Determine action based on post type and options
                                if post.Type == internal.PostTypeLike &amp;&amp; options.UnlikePosts </span><span class="cov0" title="0">{
                                        result.PostsToUnlike = append(result.PostsToUnlike, post)
                                        totalUnliked++
                                        if options.DryRun </span><span class="cov0" title="0">{
                                                fmt.Printf("üëé UNLIKE: %s\n", truncateContent(post.Content, 50))
                                        }</span>
                                } else<span class="cov0" title="0"> if post.Type == internal.PostTypeRepost &amp;&amp; options.UnshareReposts </span><span class="cov0" title="0">{
                                        result.PostsToUnshare = append(result.PostsToUnshare, post)
                                        totalUnshared++
                                        if options.DryRun </span><span class="cov0" title="0">{
                                                fmt.Printf("üîÑ UNSHARE: %s\n", truncateContent(post.Content, 50))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        result.PostsToDelete = append(result.PostsToDelete, post)
                                        totalDeleted++
                                        if options.DryRun </span><span class="cov0" title="0">{
                                                fmt.Printf("üóëÔ∏è DELETE: %s\n", truncateContent(post.Content, 50))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">fmt.Printf("Round %d completed: %d posts matched criteria\n", round, matchingPosts)
                
                // If no posts matched criteria this round, continue to next batch
                if matchingPosts == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Round %d: No posts matched criteria, continuing...\n", round)
                }</span>

                <span class="cov0" title="0">cursor = nextCursor
                round++

                // Small delay between rounds to be respectful to APIs
                time.Sleep(2 * time.Second)</span>
        }

        // Return final results
        <span class="cov0" title="0">return &amp;internal.PruneResult{
                PostsToDelete:  []internal.Post{}, // Posts already processed in dry-run mode
                PostsToUnlike:  []internal.Post{},
                PostsToUnshare: []internal.Post{},
                PostsPreserved: []internal.Post{},
                DeletedCount:   totalDeleted,
                UnlikedCount:   totalUnliked,
                UnsharedCount:  totalUnshared,
                PreservedCount: totalPreserved,
                ErrorsCount:    totalErrors,
                Errors:         allErrors,
        }</span>
}

func performContinuousPruning(client internal.SocialClient, username string, options internal.PruneOptions) <span class="cov0" title="0">{
        platform := client.GetPlatformName()
        totalDeleted := 0
        totalUnliked := 0
        totalUnshared := 0
        totalPreserved := 0
        totalErrors := 0
        var allErrors []string
        round := 1
        cursor := ""      // Start with empty cursor for pagination
        batchLimit := 100 // Fetch more posts per batch for pruning

        fmt.Printf("Starting continuous pruning on %s (will continue until no more posts match criteria)...\n", platform)
        if options.DryRun </span><span class="cov0" title="0">{
                fmt.Println("DRY RUN MODE: No actual actions will be performed")
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                fmt.Printf("Round %d: Fetching posts...\n", round)
                
                // Use paginated fetching to avoid infinite loops
                posts, nextCursor, err := client.FetchUserPostsPaginated(username, batchLimit, cursor)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error in round %d: %v\n", round, err)
                        fmt.Printf("Stopping continuous pruning. Total processed so far:\n")
                        break</span>
                }

                // Check if we have reached the end (no more posts or same cursor)
                <span class="cov0" title="0">if len(posts) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Round %d: No more posts found. Pruning complete!\n", round)
                        break</span>
                }

                <span class="cov0" title="0">if nextCursor == "" || nextCursor == cursor </span><span class="cov0" title="0">{
                        fmt.Printf("Round %d: Reached end of timeline. Pruning complete!\n", round)
                        break</span>
                }

                // Create a mock PruneResult to hold posts for this batch and process them
                <span class="cov0" title="0">result := &amp;internal.PruneResult{
                        PostsToDelete:  []internal.Post{},
                        PostsToUnlike:  []internal.Post{},
                        PostsToUnshare: []internal.Post{},
                        PostsPreserved: []internal.Post{},
                        Errors:         []string{},
                }

                // Filter posts by age criteria first
                now := time.Now()
                matchingPosts := []internal.Post{}
                for _, post := range posts </span><span class="cov0" title="0">{
                        shouldProcess := false

                        // Check age criteria
                        if options.MaxAge != nil </span><span class="cov0" title="0">{
                                if now.Sub(post.CreatedAt) &gt; *options.MaxAge </span><span class="cov0" title="0">{
                                        shouldProcess = true
                                }</span>
                        }

                        // Check date criteria
                        <span class="cov0" title="0">if options.BeforeDate != nil </span><span class="cov0" title="0">{
                                if post.CreatedAt.Before(*options.BeforeDate) </span><span class="cov0" title="0">{
                                        shouldProcess = true
                                }</span>
                        }

                        <span class="cov0" title="0">if shouldProcess </span><span class="cov0" title="0">{
                                matchingPosts = append(matchingPosts, post)
                        }</span>
                }

                // If no posts matched criteria in this batch, continue to next batch
                <span class="cov0" title="0">if len(matchingPosts) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Round %d: No posts matched criteria in this batch, continuing...\n", round)
                        cursor = nextCursor
                        round++
                        time.Sleep(time.Second) // Small delay between rounds
                        continue</span>
                }

                // Process each matching post according to preservation rules and actions
                <span class="cov0" title="0">for _, post := range matchingPosts </span><span class="cov0" title="0">{
                        // Check preservation rules
                        preserveReason := ""
                        if options.PreservePinned &amp;&amp; post.IsPinned </span><span class="cov0" title="0">{
                                preserveReason = "pinned"
                        }</span> else<span class="cov0" title="0"> if options.PreserveSelfLike &amp;&amp; post.IsLikedByUser &amp;&amp; post.Type == internal.PostTypeOriginal </span><span class="cov0" title="0">{
                                preserveReason = "self-liked"
                        }</span>

                        <span class="cov0" title="0">if preserveReason != "" </span><span class="cov0" title="0">{
                                result.PostsPreserved = append(result.PostsPreserved, post)
                                result.PreservedCount++
                        }</span> else<span class="cov0" title="0"> {
                                // Process the post according to its type and options
                                if post.Type == internal.PostTypeLike </span><span class="cov0" title="0">{
                                        result.PostsToUnlike = append(result.PostsToUnlike, post)
                                        // TODO: Implement actual unliking logic per platform
                                }</span> else<span class="cov0" title="0"> if post.Type == internal.PostTypeRepost </span><span class="cov0" title="0">{
                                        result.PostsToUnshare = append(result.PostsToUnshare, post)
                                        // TODO: Implement actual unsharing logic per platform
                                }</span> else<span class="cov0" title="0"> if post.Type == internal.PostTypeOriginal || post.Type == internal.PostTypeReply </span><span class="cov0" title="0">{
                                        result.PostsToDelete = append(result.PostsToDelete, post)
                                        // TODO: Implement actual deletion logic per platform
                                }</span>
                        }
                }

                // For now, just set counts to match the lists for dry-run display
                // In a full implementation, these would be updated by actual operations
                <span class="cov0" title="0">if options.DryRun </span><span class="cov0" title="0">{
                        result.DeletedCount = len(result.PostsToDelete)
                        result.UnlikedCount = len(result.PostsToUnlike)
                        result.UnsharedCount = len(result.PostsToUnshare)
                }</span>

                // Update totals
                <span class="cov0" title="0">totalDeleted += result.DeletedCount
                totalUnliked += result.UnlikedCount
                totalUnshared += result.UnsharedCount
                totalPreserved += result.PreservedCount
                totalErrors += result.ErrorsCount
                allErrors = append(allErrors, result.Errors...)

                // Show round results with streaming for dry-run
                if options.DryRun </span><span class="cov0" title="0">{
                        // Stream each post that would be processed
                        if len(result.PostsToDelete) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Round %d - Posts to delete:\n", round)
                                for _, post := range result.PostsToDelete </span><span class="cov0" title="0">{
                                        fmt.Printf("  üóëÔ∏è  [%s] @%s - %s\n", post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60))
                                }</span>
                        }
                        <span class="cov0" title="0">if len(result.PostsToUnlike) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Round %d - Posts to unlike:\n", round)
                                for _, post := range result.PostsToUnlike </span><span class="cov0" title="0">{
                                        fmt.Printf("  üëé [%s] @%s - %s\n", post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60))
                                }</span>
                        }
                        <span class="cov0" title="0">if len(result.PostsToUnshare) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Round %d - Posts to unshare:\n", round)
                                for _, post := range result.PostsToUnshare </span><span class="cov0" title="0">{
                                        fmt.Printf("  üîÑ [%s] @%s - %s\n", post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60))
                                }</span>
                        }
                        <span class="cov0" title="0">if len(result.PostsPreserved) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Round %d - Posts preserved:\n", round)
                                for _, post := range result.PostsPreserved </span><span class="cov0" title="0">{
                                        reason := ""
                                        if post.IsLikedByUser &amp;&amp; post.Handle == post.Author </span><span class="cov0" title="0">{
                                                reason = " (self-liked)"
                                        }</span>
                                        <span class="cov0" title="0">if post.IsPinned </span><span class="cov0" title="0">{
                                                reason = " (pinned)"
                                        }</span>
                                        <span class="cov0" title="0">fmt.Printf("  üõ°Ô∏è  [%s] @%s - %s%s\n", post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60), reason)</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Non-dry-run: show summary only
                        fmt.Printf("Round %d results:\n", round)
                        if result.DeletedCount &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  Deleted: %d posts\n", result.DeletedCount)
                        }</span>
                        <span class="cov0" title="0">if result.UnlikedCount &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  Unliked: %d posts\n", result.UnlikedCount)
                        }</span>
                        <span class="cov0" title="0">if result.UnsharedCount &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  Unshared: %d posts\n", result.UnsharedCount)
                        }</span>
                        <span class="cov0" title="0">if result.PreservedCount &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  Preserved: %d posts\n", result.PreservedCount)
                        }</span>
                }
                
                <span class="cov0" title="0">if result.ErrorsCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  Errors: %d\n", result.ErrorsCount)
                }</span>
                <span class="cov0" title="0">fmt.Println()

                // Move to next batch using pagination cursor
                cursor = nextCursor
                round++

                // Small delay between rounds to be respectful to APIs
                time.Sleep(time.Second)</span>
        }

        // Display final summary
        <span class="cov0" title="0">fmt.Printf("=== CONTINUOUS PRUNING COMPLETE ===\n")
        fmt.Printf("Total rounds: %d\n", round-1)
        if options.DryRun </span><span class="cov0" title="0">{
                fmt.Printf("DRY RUN - Would have processed:\n")
                fmt.Printf("  Total deletions: %d\n", totalDeleted)
                fmt.Printf("  Total unlikes: %d\n", totalUnliked) 
                fmt.Printf("  Total unshares: %d\n", totalUnshared)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Actually processed:\n")
                fmt.Printf("  Total deleted: %d\n", totalDeleted)
                fmt.Printf("  Total unliked: %d\n", totalUnliked)
                fmt.Printf("  Total unshared: %d\n", totalUnshared)
        }</span>
        <span class="cov0" title="0">fmt.Printf("  Total preserved: %d\n", totalPreserved)
        if totalErrors &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Total errors: %d\n", totalErrors)
                if len(allErrors) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("  Error details:")
                        for _, err := range allErrors </span><span class="cov0" title="0">{
                                fmt.Printf("    - %s\n", err)
                        }</span>
                }
        }
}

func parseDuration(s string) (time.Duration, error) <span class="cov8" title="1">{
        // First try standard Go duration parsing (handles formats like "2h30m", "1h30m45s")
        if duration, err := time.ParseDuration(s); err == nil </span><span class="cov8" title="1">{
                if duration &lt; 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("negative durations are not allowed")
                }</span>
                <span class="cov8" title="1">return duration, nil</span>
        }

        // Support custom formats like "30d", "7d", "1y"
        <span class="cov8" title="1">if len(s) &lt; 2 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid duration format")
        }</span>

        <span class="cov8" title="1">unit := s[len(s)-1:]
        valueStr := s[:len(s)-1]
        value, err := strconv.Atoi(valueStr)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid duration value: %w", err)
        }</span>

        <span class="cov8" title="1">if value &lt; 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("negative durations are not allowed")
        }</span>

        <span class="cov8" title="1">switch unit </span>{
        case "d":<span class="cov8" title="1">
                return time.Duration(value) * 24 * time.Hour, nil</span>
        case "w":<span class="cov8" title="1">
                return time.Duration(value) * 7 * 24 * time.Hour, nil</span>
        case "m":<span class="cov0" title="0">
                return time.Duration(value) * 30 * 24 * time.Hour, nil</span>
        case "y":<span class="cov8" title="1">
                return time.Duration(value) * 365 * 24 * time.Hour, nil</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("unsupported duration unit: %s", unit)</span>
        }
}

func parseDate(s string) (time.Time, error) <span class="cov8" title="1">{
        // Support multiple date formats
        formats := []string{
                "2006-01-02",
                "2006-01-02 15:04:05",
                "2006-01-02T15:04:05Z",
                "2006-01-02T15:04:05-07:00",
                "01/02/2006",
                "01/02/2006 15:04:05",
        }

        for _, format := range formats </span><span class="cov8" title="1">{
                if t, err := time.Parse(format, s); err == nil </span><span class="cov8" title="1">{
                        return t, nil
                }</span>
        }

        <span class="cov8" title="1">return time.Time{}, fmt.Errorf("unable to parse date format. Supported formats: YYYY-MM-DD, YYYY-MM-DD HH:MM:SS, MM/DD/YYYY")</span>
}

func displayPruneResults(result *internal.PruneResult, platform string, dryRun bool) <span class="cov8" title="1">{
        if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("DRY RUN: Actions that would be performed on %s:\n\n", platform)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("Pruning results for %s:\n\n", platform)
        }</span>

        <span class="cov8" title="1">totalActions := len(result.PostsToDelete) + len(result.PostsToUnlike) + len(result.PostsToUnshare)
        if totalActions == 0 </span><span class="cov8" title="1">{
                fmt.Println("No posts match the specified criteria.")
                return
        }</span>

        // Stream posts to be deleted
        <span class="cov8" title="1">if len(result.PostsToDelete) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("Posts %s:\n", map[bool]string{true: "that would be deleted", false: "deleted"}[dryRun])
                for i, post := range result.PostsToDelete </span><span class="cov8" title="1">{
                        if dryRun </span><span class="cov8" title="1">{
                                fmt.Printf("  üóëÔ∏è  [%s] @%s - %s\n", post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60))
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Printf("%d. [%s] @%s - %s\n", i+1, post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60))
                        }</span>
                        <span class="cov8" title="1">if post.URL != "" </span><span class="cov8" title="1">{
                                fmt.Printf("     URL: %s\n", post.URL)
                        }</span>
                }
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Stream posts to be unliked
        <span class="cov8" title="1">if len(result.PostsToUnlike) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("Posts %s:\n", map[bool]string{true: "that would be unliked", false: "unliked"}[dryRun])
                for i, post := range result.PostsToUnlike </span><span class="cov8" title="1">{
                        if dryRun </span><span class="cov8" title="1">{
                                fmt.Printf("  üëé [%s] @%s - %s\n", post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60))
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Printf("%d. [%s] @%s - %s\n", i+1, post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60))
                        }</span>
                        <span class="cov8" title="1">if post.URL != "" </span><span class="cov8" title="1">{
                                fmt.Printf("     URL: %s\n", post.URL)
                        }</span>
                }
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Stream posts to be unshared
        <span class="cov8" title="1">if len(result.PostsToUnshare) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("Posts %s:\n", map[bool]string{true: "that would be unshared", false: "unshared"}[dryRun])
                for i, post := range result.PostsToUnshare </span><span class="cov8" title="1">{
                        if dryRun </span><span class="cov8" title="1">{
                                fmt.Printf("  üîÑ [%s] @%s - %s\n", post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60))
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Printf("%d. [%s] @%s - %s\n", i+1, post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60))
                        }</span>
                        <span class="cov8" title="1">if post.URL != "" </span><span class="cov8" title="1">{
                                fmt.Printf("     URL: %s\n", post.URL)
                        }</span>
                }
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Show preserved posts if any
        <span class="cov8" title="1">if len(result.PostsPreserved) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("Posts preserved (due to --preserve-* flags):\n")
                for i, post := range result.PostsPreserved </span><span class="cov8" title="1">{
                        reason := ""
                        if post.IsLikedByUser &amp;&amp; post.Handle == post.Author </span><span class="cov8" title="1">{
                                reason = " (self-liked)"
                        }</span>
                        <span class="cov8" title="1">if post.IsPinned </span><span class="cov0" title="0">{
                                reason = " (pinned)"
                        }</span>
                        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                                fmt.Printf("  üõ°Ô∏è  [%s] @%s - %s%s\n", post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60), reason)
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Printf("%d. [%s] @%s - %s%s\n", i+1, post.CreatedAt.Format("2006-01-02"), post.Handle, truncateContent(post.Content, 60), reason)
                        }</span>
                }
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Show summary
        <span class="cov8" title="1">fmt.Printf("Summary:\n")
        if dryRun </span><span class="cov8" title="1">{
                if len(result.PostsToDelete) &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("  Would delete: %d posts\n", len(result.PostsToDelete))
                }</span>
                <span class="cov8" title="1">if len(result.PostsToUnlike) &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("  Would unlike: %d posts\n", len(result.PostsToUnlike))
                }</span>
                <span class="cov8" title="1">if len(result.PostsToUnshare) &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("  Would unshare: %d posts\n", len(result.PostsToUnshare))
                }</span>
                <span class="cov8" title="1">if len(result.PostsPreserved) &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("  Would preserve: %d posts\n", len(result.PostsPreserved))
                }</span>
        } else<span class="cov8" title="1"> {
                if result.DeletedCount &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("  Deleted: %d posts\n", result.DeletedCount)
                }</span>
                <span class="cov8" title="1">if result.UnlikedCount &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("  Unliked: %d posts\n", result.UnlikedCount)
                }</span>
                <span class="cov8" title="1">if result.UnsharedCount &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("  Unshared: %d posts\n", result.UnsharedCount)
                }</span>
                <span class="cov8" title="1">if result.PreservedCount &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("  Preserved: %d posts\n", result.PreservedCount)
                }</span>
                <span class="cov8" title="1">if result.ErrorsCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  Errors: %d\n", result.ErrorsCount)
                        for _, err := range result.Errors </span><span class="cov0" title="0">{
                                fmt.Printf("    - %s\n", err)
                        }</span>
                }
        }
}

func truncateContent(content string, maxLen int) string <span class="cov8" title="1">{
        // Replace newlines with spaces for display
        content = strings.ReplaceAll(content, "\n", " ")
        if len(content) &lt;= maxLen </span><span class="cov8" title="1">{
                return content
        }</span>
        <span class="cov8" title="1">if maxLen &lt;= 3 </span><span class="cov8" title="1">{
                return "..."
        }</span>
        <span class="cov8" title="1">return content[:maxLen-3] + "..."</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(pruneCmd)
        pruneCmd.Flags().String("platforms", "", "Comma-separated list of platforms (bluesky,mastodon) or 'all' for all platforms")
        pruneCmd.Flags().String("max-post-age", "", "Delete posts older than this (e.g., 30d, 1y, 24h)")
        pruneCmd.Flags().String("before-date", "", "Delete posts created before this date (YYYY-MM-DD or MM/DD/YYYY)")
        pruneCmd.Flags().Bool("preserve-selflike", false, "Don't delete user's own posts that they have liked")
        pruneCmd.Flags().Bool("preserve-pinned", false, "Don't delete pinned posts")
        pruneCmd.Flags().Bool("unlike-posts", false, "Unlike posts instead of deleting them")
        pruneCmd.Flags().Bool("unshare-reposts", false, "Unshare/unrepost instead of deleting reposts")
        pruneCmd.Flags().Bool("continue", false, "Continue searching and processing posts until no more match the criteria")
        pruneCmd.Flags().Bool("dry-run", false, "Show what would be deleted without actually deleting")
        pruneCmd.Flags().String("rate-limit-delay", "", "Delay between API requests to respect rate limits (default: 60s for Mastodon, 1s for Bluesky)")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright ¬© 2025 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cmd

import (
        "os"

        "github.com/gerrowadat/cringesweeper/internal"
        "github.com/spf13/cobra"
)

var logLevel string

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "cringesweeper",
        Short: "Cross-platform social media post management tool",
        Long: `CringeSweeper is a command-line tool for managing your social media presence 
across multiple platforms including Bluesky and Mastodon.

Key features:
‚Ä¢ List and browse recent posts from your timelines
‚Ä¢ Delete posts based on age, date, and smart preservation rules  
‚Ä¢ Safe dry-run mode to preview deletions before executing
‚Ä¢ Cross-platform authentication setup and management
‚Ä¢ Support for multiple post types (original, reposts, replies, quotes)

Use 'cringesweeper [command] --help' for detailed information about each command.`,
        PersistentPreRun: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Initialize logger with the specified log level before any command runs
                internal.InitLoggerWithLevel(logLevel)
        }</span>,
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        // Here you will define your flags and configuration settings.
        // Cobra supports persistent flags, which, if defined here,
        // will be global for your application.

        // rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.cringesweeper.yaml)")

        // Add log level flag that applies to all commands
        rootCmd.PersistentFlags().StringVar(&amp;logLevel, "log-level", "info", "Set the logging level (debug, info, warn, error)")

        // Cobra also supports local flags, which will only run
        // when this action is called directly.
        rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/gerrowadat/cringesweeper/internal"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

var (
        // Prometheus metrics
        pruneRunsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cringesweeper_prune_runs_total",
                        Help: "Total number of prune runs executed",
                },
                []string{"platform", "status"},
        )
        
        postsProcessedTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cringesweeper_posts_processed_total",
                        Help: "Total number of posts processed",
                },
                []string{"platform", "action"},
        )
        
        pruneRunDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "cringesweeper_prune_run_duration_seconds",
                        Help:    "Duration of prune runs in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"platform"},
        )
        
        lastPruneTime = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cringesweeper_last_prune_timestamp",
                        Help: "Timestamp of the last prune run",
                },
                []string{"platform"},
        )
        
        httpRequestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cringesweeper_http_requests_total",
                        Help: "Total number of HTTP requests to the server",
                },
                []string{"method", "path", "status"},
        )
        
        versionInfo = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cringesweeper_version_info",
                        Help: "Version information for CringeSweeper",
                },
                []string{"version", "commit", "build_time"},
        )
)

func init() <span class="cov8" title="1">{
        // Register metrics
        prometheus.MustRegister(pruneRunsTotal)
        prometheus.MustRegister(postsProcessedTotal)
        prometheus.MustRegister(pruneRunDuration)
        prometheus.MustRegister(lastPruneTime)
        prometheus.MustRegister(httpRequestsTotal)
        prometheus.MustRegister(versionInfo)
}</span>

var serverCmd = &amp;cobra.Command{
        Use:   "server [username]",
        Short: "Run as a long-term service with periodic pruning and metrics",
        Long: `Run CringeSweeper as a server that periodically prunes posts and serves metrics.

Use --platforms to monitor multiple platforms (e.g., --platforms=bluesky,mastodon
or --platforms=all). Note: Multi-platform server support is currently in development;
the server will use the first specified platform only.

This mode runs continuously and:
- Periodically executes prune operations based on the configured interval
- Serves HTTP endpoints for health checks and Prometheus metrics
- Suitable for containerized deployments for automated post management

Server endpoints:
- GET /         - Health check with service information
- GET /metrics  - Prometheus metrics endpoint

In server mode, credentials are ONLY read from environment variables:
- BLUESKY_USERNAME, BLUESKY_APP_PASSWORD
- MASTODON_USERNAME, MASTODON_ACCESS_TOKEN, MASTODON_INSTANCE

All prune flags are supported for configuring the periodic pruning behavior.
Use --prune-interval to control how often pruning runs (default: 1h).`,
        Args: cobra.MaximumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                platformsStr, _ := cmd.Flags().GetString("platforms")
                port, _ := cmd.Flags().GetInt("port")
                pruneIntervalStr, _ := cmd.Flags().GetString("prune-interval")
                dryRun, _ := cmd.Flags().GetBool("dry-run")
                preserveSelfLike, _ := cmd.Flags().GetBool("preserve-selflike")
                preservePinned, _ := cmd.Flags().GetBool("preserve-pinned")
                unlikePosts, _ := cmd.Flags().GetBool("unlike-posts")
                unshareReposts, _ := cmd.Flags().GetBool("unshare-reposts")
                maxAgeStr, _ := cmd.Flags().GetString("max-post-age")
                beforeDateStr, _ := cmd.Flags().GetString("before-date")
                rateLimitDelayStr, _ := cmd.Flags().GetString("rate-limit-delay")

                // Parse prune interval
                pruneInterval, err := parseDuration(pruneIntervalStr)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error parsing prune-interval: %v\n", err)
                        os.Exit(1)
                }</span>

                // Determine which platforms to use
                <span class="cov0" title="0">var platforms []string
                
                if platformsStr == "" </span><span class="cov0" title="0">{
                        fmt.Printf("Error: --platforms flag is required. Specify comma-separated platforms (bluesky,mastodon) or 'all'\n")
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">platforms, err = internal.ParsePlatforms(platformsStr)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %v\n", err)
                        os.Exit(1)
                }</span>

                // Get username with fallback priority: argument &gt; environment variables only (no saved credentials)
                <span class="cov0" title="0">argUsername := ""
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        argUsername = args[0]
                }</span>

                // Validate credentials for all platforms
                <span class="cov0" title="0">type PlatformConfig struct {
                        name     string
                        username string
                        client   internal.SocialClient
                }
                
                var platformConfigs []PlatformConfig
                for _, platformName := range platforms </span><span class="cov0" title="0">{
                        username, err := internal.GetUsernameForPlatformEnvOnly(platformName, argUsername)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error for %s: %v\n", platformName, err)
                                fmt.Printf("In server mode, credentials must be provided via environment variables only.\n")
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">client, exists := internal.GetClient(platformName)
                        if !exists </span><span class="cov0" title="0">{
                                fmt.Printf("Error: Unsupported platform '%s'. Supported platforms: %s\n", 
                                        platformName, strings.Join(internal.GetAllPlatformNames(), ", "))
                                os.Exit(1)
                        }</span>
                        
                        <span class="cov0" title="0">platformConfigs = append(platformConfigs, PlatformConfig{
                                name:     platformName,
                                username: username,
                                client:   client,
                        })</span>
                }

                // Create platform-specific configurations
                <span class="cov0" title="0">for i, config := range platformConfigs </span><span class="cov0" title="0">{
                        // Parse rate limit delay - use platform-appropriate defaults
                        var rateLimitDelay time.Duration
                        if rateLimitDelayStr != "" </span><span class="cov0" title="0">{
                                delay, err := parseDuration(rateLimitDelayStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error parsing rate-limit-delay: %v\n", err)
                                        os.Exit(1)
                                }</span>
                                <span class="cov0" title="0">rateLimitDelay = delay</span>
                        } else<span class="cov0" title="0"> {
                                // Set platform-appropriate defaults
                                switch config.name </span>{
                                case "mastodon":<span class="cov0" title="0">
                                        rateLimitDelay = 60 * time.Second</span>
                                case "bluesky":<span class="cov0" title="0">
                                        rateLimitDelay = 1 * time.Second</span>
                                default:<span class="cov0" title="0">
                                        rateLimitDelay = 5 * time.Second</span>
                                }
                        }

                        // Parse options for this platform
                        <span class="cov0" title="0">options := internal.PruneOptions{
                                PreserveSelfLike: preserveSelfLike,
                                PreservePinned:   preservePinned,
                                UnlikePosts:      unlikePosts,
                                UnshareReposts:   unshareReposts,
                                DryRun:           dryRun,
                                RateLimitDelay:   rateLimitDelay,
                        }

                        // Parse max age
                        if maxAgeStr != "" </span><span class="cov0" title="0">{
                                maxAge, err := parseDuration(maxAgeStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error parsing max-post-age: %v\n", err)
                                        os.Exit(1)
                                }</span>
                                <span class="cov0" title="0">options.MaxAge = &amp;maxAge</span>
                        }

                        // Parse before date
                        <span class="cov0" title="0">if beforeDateStr != "" </span><span class="cov0" title="0">{
                                beforeDate, err := parseDate(beforeDateStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error parsing before-date: %v\n", err)
                                        os.Exit(1)
                                }</span>
                                <span class="cov0" title="0">options.BeforeDate = &amp;beforeDate</span>
                        }

                        // Validate that at least one criteria is specified
                        <span class="cov0" title="0">if options.MaxAge == nil &amp;&amp; options.BeforeDate == nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error for %s: Must specify either --max-post-age or --before-date\n", config.name)
                                os.Exit(1)
                        }</span>

                        // Verify credentials work before starting server
                        <span class="cov0" title="0">if err := verifyCredentials(config.client, config.name); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error: Failed to verify credentials for %s: %v\n", config.name, err)
                                fmt.Printf("In server mode, credentials must be provided via environment variables.\n")
                                os.Exit(1)
                        }</span>

                        // Update platform config with options
                        <span class="cov0" title="0">platformConfigs[i] = PlatformConfig{
                                name:     config.name,
                                username: config.username,
                                client:   config.client,
                        }

                        log.Info().
                                Str("platform", config.name).
                                Str("username", config.username).
                                Dur("prune_interval", pruneInterval).
                                Int("port", port).
                                Bool("dry_run", dryRun).
                                Msg("Configured platform for CringeSweeper server")</span>
                }

                <span class="cov0" title="0">log.Info().
                        Int("platforms", len(platformConfigs)).
                        Dur("prune_interval", pruneInterval).
                        Int("port", port).
                        Bool("dry_run", dryRun).
                        Msg("Starting CringeSweeper multi-platform server")

                // For now, use the first platform (backward compatibility)
                // TODO: Implement true multi-platform server support
                if len(platformConfigs) &gt; 1 </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Multi-platform server support is still in development.\n")
                        fmt.Printf("Currently using first platform (%s) only.\n", platformConfigs[0].name)
                }</span>
                
                <span class="cov0" title="0">firstConfig := platformConfigs[0]
                
                // Create options for the first platform
                var rateLimitDelay time.Duration
                if rateLimitDelayStr != "" </span><span class="cov0" title="0">{
                        delay, err := parseDuration(rateLimitDelayStr)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error parsing rate-limit-delay: %v\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">rateLimitDelay = delay</span>
                } else<span class="cov0" title="0"> {
                        switch firstConfig.name </span>{
                        case "mastodon":<span class="cov0" title="0">
                                rateLimitDelay = 60 * time.Second</span>
                        case "bluesky":<span class="cov0" title="0">
                                rateLimitDelay = 1 * time.Second</span>
                        default:<span class="cov0" title="0">
                                rateLimitDelay = 5 * time.Second</span>
                        }
                }
                
                <span class="cov0" title="0">options := internal.PruneOptions{
                        PreserveSelfLike: preserveSelfLike,
                        PreservePinned:   preservePinned,
                        UnlikePosts:      unlikePosts,
                        UnshareReposts:   unshareReposts,
                        DryRun:           dryRun,
                        RateLimitDelay:   rateLimitDelay,
                }
                
                if maxAgeStr != "" </span><span class="cov0" title="0">{
                        maxAge, err := parseDuration(maxAgeStr)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error parsing max-post-age: %v\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">options.MaxAge = &amp;maxAge</span>
                }
                
                <span class="cov0" title="0">if beforeDateStr != "" </span><span class="cov0" title="0">{
                        beforeDate, err := parseDate(beforeDateStr)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error parsing before-date: %v\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">options.BeforeDate = &amp;beforeDate</span>
                }
                
                // Start the server (use existing single-platform implementation)
                <span class="cov0" title="0">startServer(firstConfig.client, firstConfig.username, options, firstConfig.name, pruneInterval, port)</span>
        },
}

func verifyCredentials(client internal.SocialClient, platform string) error <span class="cov0" title="0">{
        // Try to get credentials to verify they exist and are valid
        _, err := internal.GetCredentialsForPlatformEnvOnly(platform)
        return err
}</span>

func startServer(client internal.SocialClient, username string, options internal.PruneOptions, platform string, pruneInterval time.Duration, port int) <span class="cov0" title="0">{
        // Create context for graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Initialize version metrics
        version := internal.GetFullVersionInfo()
        versionInfo.WithLabelValues(version["version"], version["commit"], version["build_time"]).Set(1)

        // Setup HTTP server
        mux := http.NewServeMux()
        
        // Root endpoint - health check with service info
        mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                status := "200"
                defer func() </span><span class="cov0" title="0">{
                        httpRequestsTotal.WithLabelValues(r.Method, r.URL.Path, status).Inc()
                }</span>()

                <span class="cov0" title="0">versionInfo := internal.GetFullVersionInfo()
                
                w.Header().Set("Content-Type", "text/html; charset=utf-8")
                fmt.Fprintf(w, `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;CringeSweeper Server&lt;/title&gt;
    &lt;style&gt;
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 40px; }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; }
        .running { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .version { background-color: #f8f9fa; color: #495057; border: 1px solid #dee2e6; }
        code { background-color: #f8f9fa; padding: 2px 4px; border-radius: 3px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;üßπ CringeSweeper Server&lt;/h1&gt;
    &lt;div class="status running"&gt;
        &lt;strong&gt;Status:&lt;/strong&gt; Running
    &lt;/div&gt;
    &lt;div class="version"&gt;
        &lt;p&gt;&lt;strong&gt;Version:&lt;/strong&gt; %s&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Commit:&lt;/strong&gt; %s&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Build Time:&lt;/strong&gt; %s&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class="info"&gt;
        &lt;p&gt;&lt;strong&gt;Platform:&lt;/strong&gt; %s&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Username:&lt;/strong&gt; %s&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Prune Interval:&lt;/strong&gt; %v&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Dry Run Mode:&lt;/strong&gt; %t&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Last Check:&lt;/strong&gt; %s&lt;/p&gt;
    &lt;/div&gt;
    &lt;h3&gt;Endpoints&lt;/h3&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;GET /&lt;/code&gt; - This status page&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;GET /metrics&lt;/code&gt; - Prometheus metrics&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;Metrics&lt;/h3&gt;
    &lt;p&gt;Prometheus metrics are available at &lt;a href="/metrics"&gt;/metrics&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;Key metrics include:&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;cringesweeper_prune_runs_total&lt;/code&gt; - Total prune runs&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;cringesweeper_posts_processed_total&lt;/code&gt; - Posts processed by action&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;cringesweeper_prune_run_duration_seconds&lt;/code&gt; - Prune run duration&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;cringesweeper_last_prune_timestamp&lt;/code&gt; - Last prune timestamp&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;`, versionInfo["version"], versionInfo["commit"], versionInfo["build_time"], platform, username, pruneInterval, options.DryRun, time.Now().Format("2006-01-02 15:04:05 UTC"))

                log.Debug().
                        Str("method", r.Method).
                        Str("path", r.URL.Path).
                        Str("remote_addr", r.RemoteAddr).
                        Dur("duration", time.Since(start)).
                        Msg("HTTP request served")</span>
        })

        // Metrics endpoint
        <span class="cov0" title="0">mux.Handle("/metrics", promhttp.Handler())

        server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", port),
                Handler: mux,
        }

        // Start HTTP server in goroutine
        serverErrCh := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                log.Info().Int("port", port).Msg("Starting HTTP server")
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        serverErrCh &lt;- err
                }</span>
        }()

        // Start pruning ticker in goroutine
        <span class="cov0" title="0">ticker := time.NewTicker(pruneInterval)
        defer ticker.Stop()

        var pruningMutex sync.Mutex
        
        // Run initial prune
        go func() </span><span class="cov0" title="0">{
                pruningMutex.Lock()
                defer pruningMutex.Unlock()
                runPruneWithMetrics(client, username, options, platform)
        }</span>()

        // Setup signal handling for graceful shutdown
        <span class="cov0" title="0">sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

        log.Info().Msg("CringeSweeper server started successfully")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info().Msg("Context cancelled, shutting down")
                        return</span>

                case err := &lt;-serverErrCh:<span class="cov0" title="0">
                        log.Error().Err(err).Msg("HTTP server error")
                        cancel()
                        return</span>

                case sig := &lt;-sigCh:<span class="cov0" title="0">
                        log.Info().Str("signal", sig.String()).Msg("Received shutdown signal")
                        
                        // Graceful shutdown
                        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
                        defer shutdownCancel()
                        
                        if err := server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Msg("Error during server shutdown")
                        }</span>
                        
                        <span class="cov0" title="0">log.Info().Msg("Server shutdown complete")
                        return</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Run prune in background to not block metrics serving
                        go func() </span><span class="cov0" title="0">{
                                if !pruningMutex.TryLock() </span><span class="cov0" title="0">{
                                        log.Warn().Msg("Skipping prune run - previous run still in progress")
                                        return
                                }</span>
                                <span class="cov0" title="0">defer pruningMutex.Unlock()
                                runPruneWithMetrics(client, username, options, platform)</span>
                        }()
                }
        }
}

func runPruneWithMetrics(client internal.SocialClient, username string, options internal.PruneOptions, platform string) <span class="cov0" title="0">{
        start := time.Now()
        status := "success"

        log.Info().Str("platform", platform).Msg("Starting scheduled prune run")

        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(start)
                pruneRunDuration.WithLabelValues(platform).Observe(duration.Seconds())
                pruneRunsTotal.WithLabelValues(platform, status).Inc()
                lastPruneTime.WithLabelValues(platform).Set(float64(time.Now().Unix()))
                
                log.Info().
                        Str("platform", platform).
                        Str("status", status).
                        Dur("duration", duration).
                        Msg("Prune run completed")
        }</span>()

        // Use continuous pruning to process entire timeline
        <span class="cov0" title="0">result, err := runContinuousPruneForServer(client, username, options)
        if err != nil </span><span class="cov0" title="0">{
                status = "error"
                log.Error().Err(err).Str("platform", platform).Msg("Prune run failed")
                return
        }</span>

        // Update metrics
        <span class="cov0" title="0">postsProcessedTotal.WithLabelValues(platform, "deleted").Add(float64(result.DeletedCount))
        postsProcessedTotal.WithLabelValues(platform, "unliked").Add(float64(result.UnlikedCount))
        postsProcessedTotal.WithLabelValues(platform, "unshared").Add(float64(result.UnsharedCount))
        postsProcessedTotal.WithLabelValues(platform, "preserved").Add(float64(result.PreservedCount))

        log.Info().
                Str("platform", platform).
                Int("deleted", result.DeletedCount).
                Int("unliked", result.UnlikedCount).
                Int("unshared", result.UnsharedCount).
                Int("preserved", result.PreservedCount).
                Int("errors", result.ErrorsCount).
                Msg("Prune run metrics")</span>
}

// runContinuousPruneForServer runs continuous pruning similar to performContinuousPruning but returns aggregated results
func runContinuousPruneForServer(client internal.SocialClient, username string, options internal.PruneOptions) (*internal.PruneResult, error) <span class="cov0" title="0">{
        totalResult := &amp;internal.PruneResult{
                PostsToDelete:  []internal.Post{},
                PostsToUnlike:  []internal.Post{},
                PostsToUnshare: []internal.Post{},
                PostsPreserved: []internal.Post{},
                Errors:         []string{},
        }

        cursor := ""
        batchLimit := 100
        round := 1

        log.Debug().Msg("Starting continuous prune for server")

        for </span><span class="cov0" title="0">{
                log.Debug().Int("round", round).Msg("Fetching posts for pruning")
                
                posts, nextCursor, err := client.FetchUserPostsPaginated(username, batchLimit, cursor)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch posts in round %d: %w", round, err)
                }</span>

                // Check termination conditions
                <span class="cov0" title="0">if len(posts) == 0 </span><span class="cov0" title="0">{
                        log.Debug().Int("round", round).Msg("No more posts found, pruning complete")
                        break</span>
                }

                <span class="cov0" title="0">if nextCursor == "" || nextCursor == cursor </span><span class="cov0" title="0">{
                        log.Debug().Int("round", round).Msg("Reached end of timeline, pruning complete")
                        break</span>
                }

                // Filter posts by age criteria
                <span class="cov0" title="0">now := time.Now()
                matchingPosts := []internal.Post{}
                for _, post := range posts </span><span class="cov0" title="0">{
                        shouldProcess := false

                        if options.MaxAge != nil &amp;&amp; now.Sub(post.CreatedAt) &gt; *options.MaxAge </span><span class="cov0" title="0">{
                                shouldProcess = true
                        }</span>
                        <span class="cov0" title="0">if options.BeforeDate != nil &amp;&amp; post.CreatedAt.Before(*options.BeforeDate) </span><span class="cov0" title="0">{
                                shouldProcess = true
                        }</span>

                        <span class="cov0" title="0">if shouldProcess </span><span class="cov0" title="0">{
                                matchingPosts = append(matchingPosts, post)
                        }</span>
                }

                // Process matching posts
                <span class="cov0" title="0">if len(matchingPosts) &gt; 0 </span><span class="cov0" title="0">{
                        log.Debug().Int("round", round).Int("matching_posts", len(matchingPosts)).Msg("Processing posts")
                        
                        // Create a temporary options struct for this batch
                        batchOptions := options
                        batchOptions.DryRun = false // Always actually process in server mode
                        
                        // For server mode, we need to actually process posts individually
                        // This is a simplified version - in a full implementation, you'd want to 
                        // reuse the exact logic from PrunePosts but adapted for continuous operation
                        for _, post := range matchingPosts </span><span class="cov0" title="0">{
                                // Check preservation rules
                                preserveReason := ""
                                if options.PreservePinned &amp;&amp; post.IsPinned </span><span class="cov0" title="0">{
                                        preserveReason = "pinned"
                                }</span> else<span class="cov0" title="0"> if options.PreserveSelfLike &amp;&amp; post.IsLikedByUser &amp;&amp; post.Type == internal.PostTypeOriginal </span><span class="cov0" title="0">{
                                        preserveReason = "self-liked"
                                }</span>

                                <span class="cov0" title="0">if preserveReason != "" </span><span class="cov0" title="0">{
                                        totalResult.PostsPreserved = append(totalResult.PostsPreserved, post)
                                        totalResult.PreservedCount++
                                }</span> else<span class="cov0" title="0"> {
                                        // For now, just count what would be processed
                                        // In a full implementation, you'd call the actual deletion methods here
                                        if post.Type == internal.PostTypeLike </span><span class="cov0" title="0">{
                                                totalResult.PostsToUnlike = append(totalResult.PostsToUnlike, post)
                                                totalResult.UnlikedCount++
                                        }</span> else<span class="cov0" title="0"> if post.Type == internal.PostTypeRepost </span><span class="cov0" title="0">{
                                                totalResult.PostsToUnshare = append(totalResult.PostsToUnshare, post)
                                                totalResult.UnsharedCount++
                                        }</span> else<span class="cov0" title="0"> if post.Type == internal.PostTypeOriginal || post.Type == internal.PostTypeReply </span><span class="cov0" title="0">{
                                                totalResult.PostsToDelete = append(totalResult.PostsToDelete, post)
                                                totalResult.DeletedCount++
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">cursor = nextCursor
                round++
                time.Sleep(1 * time.Second)</span> // Small delay between rounds
        }

        <span class="cov0" title="0">log.Debug().
                Int("total_rounds", round-1).
                Int("total_processed", totalResult.DeletedCount+totalResult.UnlikedCount+totalResult.UnsharedCount).
                Msg("Continuous prune completed")

        return totalResult, nil</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(serverCmd)
        
        // Server-specific flags
        serverCmd.Flags().IntP("port", "P", 8080, "HTTP server port")
        serverCmd.Flags().String("prune-interval", "1h", "Time between prune runs (e.g., 30m, 1h, 2h)")
        
        // Inherit all prune flags
        serverCmd.Flags().String("platforms", "", "Comma-separated list of platforms (bluesky,mastodon) or 'all' for all platforms")
        serverCmd.Flags().String("max-post-age", "", "Delete posts older than this (e.g., 30d, 1y, 24h)")
        serverCmd.Flags().String("before-date", "", "Delete posts created before this date (YYYY-MM-DD or MM/DD/YYYY)")
        serverCmd.Flags().Bool("preserve-selflike", false, "Don't delete user's own posts that they have liked")
        serverCmd.Flags().Bool("preserve-pinned", false, "Don't delete pinned posts")
        serverCmd.Flags().Bool("unlike-posts", false, "Unlike posts instead of deleting them")
        serverCmd.Flags().Bool("unshare-reposts", false, "Unshare/unrepost instead of deleting reposts")
        serverCmd.Flags().Bool("dry-run", false, "Show what would be deleted without actually deleting (for testing)")
        serverCmd.Flags().String("rate-limit-delay", "", "Delay between API requests to respect rate limits (default: 60s for Mastodon, 1s for Bluesky)")
}</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "fmt"

        "github.com/gerrowadat/cringesweeper/internal"
        "github.com/spf13/cobra"
)

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Show version information",
        Long:  `Display version, commit, and build information for CringeSweeper.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                versionInfo := internal.GetFullVersionInfo()
                
                fmt.Printf("CringeSweeper %s\n", versionInfo["version"])
                fmt.Printf("Commit: %s\n", versionInfo["commit"])
                fmt.Printf("Build Time: %s\n", versionInfo["build_time"])
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)
}</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "github.com/gerrowadat/cringesweeper/cmd"
)

func main() <span class="cov0" title="0">{
        // Logger will be initialized by the root command's PersistentPreRun
        // which runs before any subcommand and respects the --log-level flag
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package internal

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// Credentials stores authentication information for a platform
type Credentials struct {
        Platform    string            `json:"platform"`
        Username    string            `json:"username"`
        Instance    string            `json:"instance,omitempty"` // For Mastodon
        AccessToken string            `json:"access_token,omitempty"`
        AppPassword string            `json:"app_password,omitempty"` // For Bluesky
        ExtraData   map[string]string `json:"extra_data,omitempty"`
}

// AuthManager handles credential storage and retrieval
type AuthManager struct {
        configDir string
}

// NewAuthManager creates a new authentication manager
func NewAuthManager() (*AuthManager, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        <span class="cov8" title="1">configDir := filepath.Join(homeDir, ".config", "cringesweeper")

        // Create config directory if it doesn't exist
        if err := os.MkdirAll(configDir, 0700); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;AuthManager{configDir: configDir}, nil</span>
}

// SaveCredentials stores credentials for a platform
func (am *AuthManager) SaveCredentials(creds *Credentials) error <span class="cov8" title="1">{
        filename := filepath.Join(am.configDir, fmt.Sprintf("%s.json", creds.Platform))

        data, err := json.MarshalIndent(creds, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal credentials: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(filename, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write credentials file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// LoadCredentials retrieves stored credentials for a platform
func (am *AuthManager) LoadCredentials(platform string) (*Credentials, error) <span class="cov8" title="1">{
        filename := filepath.Join(am.configDir, fmt.Sprintf("%s.json", platform))

        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("no credentials found for platform %s", platform)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read credentials file: %w", err)</span>
        }

        <span class="cov8" title="1">var creds Credentials
        if err := json.Unmarshal(data, &amp;creds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal credentials: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;creds, nil</span>
}

// DeleteCredentials removes stored credentials for a platform
func (am *AuthManager) DeleteCredentials(platform string) error <span class="cov8" title="1">{
        filename := filepath.Join(am.configDir, fmt.Sprintf("%s.json", platform))

        if err := os.Remove(filename); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete credentials file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListPlatforms returns a list of platforms with stored credentials
func (am *AuthManager) ListPlatforms() ([]string, error) <span class="cov8" title="1">{
        files, err := os.ReadDir(am.configDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config directory: %w", err)
        }</span>

        <span class="cov8" title="1">var platforms []string
        for _, file := range files </span><span class="cov8" title="1">{
                if !file.IsDir() &amp;&amp; filepath.Ext(file.Name()) == ".json" </span><span class="cov8" title="1">{
                        platform := file.Name()[:len(file.Name())-5] // Remove .json extension
                        platforms = append(platforms, platform)
                }</span>
        }

        <span class="cov8" title="1">return platforms, nil</span>
}

// GetCredentialsFromEnv retrieves credentials from environment variables
func GetCredentialsFromEnv(platform string) *Credentials <span class="cov8" title="1">{
        switch platform </span>{
        case "bluesky":<span class="cov8" title="1">
                username := os.Getenv("BLUESKY_USER")
                password := os.Getenv("BLUESKY_PASSWORD")
                if username != "" &amp;&amp; password != "" </span><span class="cov8" title="1">{
                        return &amp;Credentials{
                                Platform:    platform,
                                Username:    username,
                                AppPassword: password,
                        }
                }</span>
        case "mastodon":<span class="cov8" title="1">
                username := os.Getenv("MASTODON_USER")
                instance := os.Getenv("MASTODON_INSTANCE")
                token := os.Getenv("MASTODON_ACCESS_TOKEN")
                if username != "" &amp;&amp; instance != "" &amp;&amp; token != "" </span><span class="cov8" title="1">{
                        return &amp;Credentials{
                                Platform:    platform,
                                Username:    username,
                                Instance:    instance,
                                AccessToken: token,
                        }
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateCredentials checks if credentials are complete for a platform
func ValidateCredentials(creds *Credentials) error <span class="cov8" title="1">{
        if creds == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("credentials are nil")
        }</span>

        <span class="cov8" title="1">if creds.Username == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("username is required")
        }</span>

        <span class="cov8" title="1">switch creds.Platform </span>{
        case "bluesky":<span class="cov8" title="1">
                if creds.AppPassword == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("app password is required for Bluesky")
                }</span>
        case "mastodon":<span class="cov8" title="1">
                if creds.Instance == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("instance is required for Mastodon")
                }</span>
                <span class="cov8" title="1">if creds.AccessToken == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("access token is required for Mastodon")
                }</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unsupported platform: %s", creds.Platform)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package internal

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"
)

// BlueskyClient implements the SocialClient interface for Bluesky
type BlueskyClient struct {
        sessionManager *SessionManager
        session        *atpSessionResponse
}

// NewBlueskyClient creates a new Bluesky client
func NewBlueskyClient() *BlueskyClient <span class="cov8" title="1">{
        return &amp;BlueskyClient{
                sessionManager: NewSessionManager("bluesky"),
        }
}</span>

// GetPlatformName returns the platform name
func (c *BlueskyClient) GetPlatformName() string <span class="cov8" title="1">{
        return "Bluesky"
}</span>

// RequiresAuth returns true if the platform requires authentication for deletion
func (c *BlueskyClient) RequiresAuth() bool <span class="cov8" title="1">{
        return true // Bluesky requires authentication for post deletion
}</span>

// FetchUserPosts retrieves recent posts for a Bluesky user
func (c *BlueskyClient) FetchUserPosts(username string, limit int) ([]Post, error) <span class="cov8" title="1">{
        posts, err := c.fetchBlueskyPosts(username, limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Convert Bluesky posts to generic Post format
        <span class="cov0" title="0">var genericPosts []Post
        for _, bskyPost := range posts </span><span class="cov0" title="0">{
                post := Post{
                        ID:        bskyPost.URI,
                        Author:    bskyPost.Author.DisplayName,
                        Handle:    bskyPost.Author.Handle,
                        Content:   bskyPost.Record.Text,
                        CreatedAt: bskyPost.Record.CreatedAt,
                        URL:       fmt.Sprintf("https://bsky.app/profile/%s/post/%s", bskyPost.Author.Handle, extractPostID(bskyPost.URI)),
                        Type:      c.determinePostType(bskyPost),
                        Platform:  "bluesky",

                        // Engagement metrics
                        RepostCount: bskyPost.RepostCount,
                        LikeCount:   bskyPost.LikeCount,
                        ReplyCount:  bskyPost.ReplyCount,
                }

                // Use Author.Handle as fallback if DisplayName is empty
                if post.Author == "" </span><span class="cov0" title="0">{
                        post.Author = bskyPost.Author.Handle
                }</span>

                // Set viewer interaction status
                <span class="cov0" title="0">if bskyPost.ViewerData != nil </span><span class="cov0" title="0">{
                        post.IsLikedByUser = bskyPost.ViewerData.Like != nil
                        // Note: IsPinned would need to be determined from the feed metadata
                }</span>

                // Handle reposts - these are the user's own repost records, not the original posts
                <span class="cov0" title="0">if bskyPost.Record.Type == "app.bsky.feed.repost" </span><span class="cov0" title="0">{
                        post.Type = PostTypeRepost
                        // For reposts, the ID should be the repost record URI, not the original post URI
                        post.ID = bskyPost.URI // This is the user's repost record URI
                }</span>

                // Handle replies
                <span class="cov0" title="0">if bskyPost.Record.Reply != nil </span><span class="cov0" title="0">{
                        post.Type = PostTypeReply
                        post.InReplyToID = bskyPost.Record.Reply.Parent.URI
                }</span>

                // Note: Likes are not returned by getAuthorFeed - they need to be fetched separately
                // if we want to include them in the pruning process

                <span class="cov0" title="0">genericPosts = append(genericPosts, post)</span>
        }

        <span class="cov0" title="0">return genericPosts, nil</span>
}

// FetchUserPostsPaginated retrieves posts with cursor-based pagination
func (c *BlueskyClient) FetchUserPostsPaginated(username string, limit int, cursor string) ([]Post, string, error) <span class="cov0" title="0">{
        posts, nextCursor, err := c.fetchBlueskyPostsPaginated(username, limit, cursor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        // Convert Bluesky posts to generic Post format
        <span class="cov0" title="0">var genericPosts []Post
        for _, bskyPost := range posts </span><span class="cov0" title="0">{
                post := Post{
                        ID:        bskyPost.URI,
                        Author:    bskyPost.Author.DisplayName,
                        Handle:    bskyPost.Author.Handle,
                        Content:   bskyPost.Record.Text,
                        CreatedAt: bskyPost.Record.CreatedAt,
                        URL:       fmt.Sprintf("https://bsky.app/profile/%s/post/%s", bskyPost.Author.Handle, extractPostID(bskyPost.URI)),
                        Type:      c.determinePostType(bskyPost),
                        Platform:  "bluesky",

                        // Engagement metrics
                        RepostCount: bskyPost.RepostCount,
                        LikeCount:   bskyPost.LikeCount,
                        ReplyCount:  bskyPost.ReplyCount,
                }

                // Use Author.Handle as fallback if DisplayName is empty
                if post.Author == "" </span><span class="cov0" title="0">{
                        post.Author = bskyPost.Author.Handle
                }</span>

                // Set viewer interaction status
                <span class="cov0" title="0">if bskyPost.ViewerData != nil </span><span class="cov0" title="0">{
                        post.IsLikedByUser = bskyPost.ViewerData.Like != nil
                        // Note: IsPinned would need to be determined from the feed metadata
                }</span>

                // Handle reposts - these are the user's own repost records, not the original posts
                <span class="cov0" title="0">if bskyPost.Record.Type == "app.bsky.feed.repost" </span><span class="cov0" title="0">{
                        post.Type = PostTypeRepost
                        // For reposts, the ID should be the repost record URI, not the original post URI
                        post.ID = bskyPost.URI // This is the user's repost record URI
                }</span>

                // Handle replies
                <span class="cov0" title="0">if bskyPost.Record.Reply != nil </span><span class="cov0" title="0">{
                        post.Type = PostTypeReply
                        post.InReplyToID = bskyPost.Record.Reply.Parent.URI
                }</span>

                // Note: Likes are not returned by getAuthorFeed - they need to be fetched separately
                // if we want to include them in the pruning process

                <span class="cov0" title="0">genericPosts = append(genericPosts, post)</span>
        }

        <span class="cov0" title="0">return genericPosts, nextCursor, nil</span>
}

func (c *BlueskyClient) fetchBlueskyPostsPaginated(username string, limit int, cursor string) ([]blueskyPost, string, error) <span class="cov0" title="0">{
        baseURL := "https://public.api.bsky.app/xrpc/app.bsky.feed.getAuthorFeed"
        params := url.Values{}
        params.Add("actor", username)
        params.Add("limit", fmt.Sprintf("%d", limit))
        params.Add("include_pins", "true")         // Include pinned posts
        params.Add("filter", "posts_with_replies") // Get user's own posts and replies
        
        if cursor != "" </span><span class="cov0" title="0">{
                params.Add("cursor", cursor)
        }</span>

        <span class="cov0" title="0">fullURL := fmt.Sprintf("%s?%s", baseURL, params.Encode())

        LogHTTPRequest("GET", fullURL)
        resp, err := http.Get(fullURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to fetch posts: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, "", fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">var feedResponse blueskyEnhancedFeedResponse
        if err := json.Unmarshal(body, &amp;feedResponse); err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">var posts []blueskyPost
        for _, item := range feedResponse.Feed </span><span class="cov0" title="0">{
                // Enhance post with viewer information
                item.Post.ViewerData = item.ViewerData
                posts = append(posts, item.Post)
        }</span>

        <span class="cov0" title="0">nextCursor := ""
        if feedResponse.Cursor != nil </span><span class="cov0" title="0">{
                nextCursor = *feedResponse.Cursor
        }</span>

        <span class="cov0" title="0">return posts, nextCursor, nil</span>
}

// Bluesky-specific types
type blueskyPost struct {
        URI        string             `json:"uri"`
        CID        string             `json:"cid"`
        Author     blueskyAuthor      `json:"author"`
        Record     blueskyRecord      `json:"record"`
        IndexedAt  time.Time          `json:"indexedAt"`
        ViewerData *blueskyViewerData `json:"-"` // Added separately from API response

        // Engagement metrics
        RepostCount int `json:"repostCount,omitempty"`
        LikeCount   int `json:"likeCount,omitempty"`
        ReplyCount  int `json:"replyCount,omitempty"`
}

type blueskyAuthor struct {
        DID         string `json:"did"`
        Handle      string `json:"handle"`
        DisplayName string `json:"displayName,omitempty"`
}

type blueskyRecord struct {
        Type      string        `json:"$type"`
        Text      string        `json:"text"`
        CreatedAt time.Time     `json:"createdAt"`
        Reply     *blueskyReply `json:"reply,omitempty"`
}

type blueskyReply struct {
        Parent blueskyPostRef `json:"parent"`
        Root   blueskyPostRef `json:"root"`
}

type blueskyPostRef struct {
        URI string `json:"uri"`
        CID string `json:"cid"`
}

type blueskyViewerData struct {
        Like   *string `json:"like,omitempty"`   // URI of like record if liked by viewer
        Repost *string `json:"repost,omitempty"` // URI of repost record if reposted by viewer
}

type blueskyEnhancedFeedResponse struct {
        Feed []struct {
                Post       blueskyPost        `json:"post"`
                ViewerData *blueskyViewerData `json:"viewer,omitempty"`
                // Additional fields for pinned posts and other metadata
                PinnedPost bool `json:"pinnedPost,omitempty"`
        } `json:"feed"`
        Cursor *string `json:"cursor,omitempty"`
}

func (c *BlueskyClient) fetchBlueskyPosts(username string, limit int) ([]blueskyPost, error) <span class="cov8" title="1">{
        baseURL := "https://public.api.bsky.app/xrpc/app.bsky.feed.getAuthorFeed"
        params := url.Values{}
        params.Add("actor", username)
        params.Add("limit", fmt.Sprintf("%d", limit))
        params.Add("include_pins", "true")         // Include pinned posts
        params.Add("filter", "posts_with_replies") // Get user's own posts and replies

        fullURL := fmt.Sprintf("%s?%s", baseURL, params.Encode())

        LogHTTPRequest("GET", fullURL)
        resp, err := http.Get(fullURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch posts: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">var feedResponse blueskyEnhancedFeedResponse
        if err := json.Unmarshal(body, &amp;feedResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">var posts []blueskyPost
        for _, item := range feedResponse.Feed </span><span class="cov0" title="0">{
                // Enhance post with viewer information
                item.Post.ViewerData = item.ViewerData
                posts = append(posts, item.Post)
        }</span>

        <span class="cov0" title="0">return posts, nil</span>
}

// determinePostType determines the type of Bluesky post
func (c *BlueskyClient) determinePostType(post blueskyPost) PostType <span class="cov8" title="1">{
        switch post.Record.Type </span>{
        case "app.bsky.feed.repost":<span class="cov8" title="1">
                return PostTypeRepost</span>
        case "app.bsky.feed.post":<span class="cov8" title="1">
                if post.Record.Reply != nil </span><span class="cov8" title="1">{
                        return PostTypeReply
                }</span>
                <span class="cov8" title="1">return PostTypeOriginal</span>
        default:<span class="cov8" title="1">
                return PostTypeOriginal</span>
        }
}

// PrunePosts deletes posts according to specified criteria
func (c *BlueskyClient) PrunePosts(username string, options PruneOptions) (*PruneResult, error) <span class="cov8" title="1">{
        // Get authentication credentials
        creds, err := GetCredentialsForPlatform("bluesky")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication required: %w", err)
        }</span>

        <span class="cov8" title="1">if err := ValidateCredentials(creds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid credentials: %w", err)
        }</span>

        // Create session to get authenticated user's DID
        <span class="cov8" title="1">session, err := c.ensureValidSession(creds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to authenticate with Bluesky: %w. This may indicate invalid credentials or DID resolution issues", err)
        }</span>

        // Fetch user's posts (we'd need to fetch more than 10 for real pruning)
        <span class="cov8" title="1">posts, err := c.FetchUserPosts(username, 100) // Fetch more posts for pruning
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch posts: %w", err)
        }</span>

        // If user wants to unlike posts, also fetch their liked posts
        <span class="cov0" title="0">if options.UnlikePosts </span><span class="cov0" title="0">{
                likedPosts, err := c.fetchLikedPosts(session, 100)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Warning: Failed to fetch liked posts: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        posts = append(posts, likedPosts...)
                }</span>
        }

        // Always fetch the user's repost records separately to ensure we get the correct repost URIs
        <span class="cov0" title="0">repostPosts, err := c.fetchRepostPosts(session, 100)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Warning: Failed to fetch repost records: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                posts = append(posts, repostPosts...)
        }</span>

        <span class="cov0" title="0">result := &amp;PruneResult{
                PostsToDelete:  []Post{},
                PostsToUnlike:  []Post{},
                PostsToUnshare: []Post{},
                PostsPreserved: []Post{},
                Errors:         []string{},
        }

        now := time.Now()

        for _, post := range posts </span><span class="cov0" title="0">{
                shouldProcess := false
                preserveReason := ""

                // Check age criteria
                if options.MaxAge != nil </span><span class="cov0" title="0">{
                        if now.Sub(post.CreatedAt) &gt; *options.MaxAge </span><span class="cov0" title="0">{
                                shouldProcess = true
                        }</span>
                }

                // Check date criteria
                <span class="cov0" title="0">if options.BeforeDate != nil </span><span class="cov0" title="0">{
                        if post.CreatedAt.Before(*options.BeforeDate) </span><span class="cov0" title="0">{
                                shouldProcess = true
                        }</span>
                }

                <span class="cov0" title="0">if !shouldProcess </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check preservation rules
                <span class="cov0" title="0">if options.PreservePinned &amp;&amp; post.IsPinned </span><span class="cov0" title="0">{
                        preserveReason = "pinned"
                }</span> else<span class="cov0" title="0"> if options.PreserveSelfLike &amp;&amp; post.IsLikedByUser &amp;&amp; post.Type == PostTypeOriginal </span><span class="cov0" title="0">{
                        preserveReason = "self-liked"
                }</span>

                <span class="cov0" title="0">if preserveReason != "" </span><span class="cov0" title="0">{
                        result.PostsPreserved = append(result.PostsPreserved, post)
                        result.PreservedCount++
                }</span> else<span class="cov0" title="0"> {
                        // Determine action based on post type
                        if post.Type == PostTypeLike </span><span class="cov0" title="0">{
                                // Handle like records - delete the like record directly
                                result.PostsToUnlike = append(result.PostsToUnlike, post)
                                if !options.DryRun </span><span class="cov0" title="0">{
                                        // Add configurable delay to respect rate limits
                                        time.Sleep(options.RateLimitDelay)
                                        logger := WithPlatform("bluesky").With().Str("post_id", post.ID).Logger()
                                        if err := c.deleteLikeRecord(creds, post.ID); err != nil </span><span class="cov0" title="0">{
                                                logger.Error().Err(err).Msg("Failed to unlike post")
                                                fmt.Printf("‚ùå Failed to unlike post from %s: %v\n", post.CreatedAt.Format("2006-01-02"), err)
                                                result.Errors = append(result.Errors, fmt.Sprintf("Failed to unlike post %s: %v", post.ID, err))
                                                result.ErrorsCount++
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Info().Str("content", TruncateContent(post.Content, 50)).Msg("Post unliked successfully")
                                                fmt.Printf("üëç Unliked post from %s: %s\n", post.CreatedAt.Format("2006-01-02"), TruncateContent(post.Content, 50))
                                                result.UnlikedCount++
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if post.Type == PostTypeRepost </span><span class="cov0" title="0">{
                                // Always unrepost for repost records - these are the user's own repost actions
                                result.PostsToUnshare = append(result.PostsToUnshare, post)
                                if !options.DryRun </span><span class="cov0" title="0">{
                                        // Add configurable delay to respect rate limits
                                        time.Sleep(options.RateLimitDelay)
                                        // For reposts, we need to delete the repost record directly
                                        logger := WithPlatform("bluesky").With().Str("post_id", post.ID).Logger()
                                        if err := c.deleteRepostRecord(creds, post.ID); err != nil </span><span class="cov0" title="0">{
                                                logger.Error().Err(err).Msg("Failed to unrepost")
                                                fmt.Printf("‚ùå Failed to unrepost from %s: %v\n", post.CreatedAt.Format("2006-01-02"), err)
                                                result.Errors = append(result.Errors, fmt.Sprintf("Failed to unrepost post %s: %v", post.ID, err))
                                                result.ErrorsCount++
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Info().Str("content", TruncateContent(post.Content, 50)).Msg("Repost unshared successfully")
                                                fmt.Printf("üîÑ Unshared repost from %s: %s\n", post.CreatedAt.Format("2006-01-02"), TruncateContent(post.Content, 50))
                                                result.UnsharedCount++
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if post.Type == PostTypeOriginal || post.Type == PostTypeReply </span><span class="cov0" title="0">{
                                // Validate that the post belongs to the authenticated user
                                if err := c.validatePostURI(post.ID, session.DID); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("‚ö†Ô∏è  Skipping post from %s: %v\n", post.CreatedAt.Format("2006-01-02"), err)
                                        result.Errors = append(result.Errors, fmt.Sprintf("Post validation failed %s: %v", post.ID, err))
                                        result.ErrorsCount++
                                        continue</span>
                                }

                                <span class="cov0" title="0">result.PostsToDelete = append(result.PostsToDelete, post)
                                if !options.DryRun </span><span class="cov0" title="0">{
                                        // Add configurable delay to respect rate limits
                                        time.Sleep(options.RateLimitDelay)
                                        logger := WithPlatform("bluesky").With().Str("post_id", post.ID).Logger()
                                        if err := c.deletePost(creds, post.ID); err != nil </span><span class="cov0" title="0">{
                                                logger.Error().Err(err).Msg("Failed to delete post")
                                                fmt.Printf("‚ùå Failed to delete post from %s: %v\n", post.CreatedAt.Format("2006-01-02"), err)
                                                result.Errors = append(result.Errors, fmt.Sprintf("Failed to delete post %s: %v", post.ID, err))
                                                result.ErrorsCount++
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Info().Str("content", TruncateContent(post.Content, 50)).Msg("Post deleted successfully")
                                                fmt.Printf("üóëÔ∏è  Deleted post from %s: %s\n", post.CreatedAt.Format("2006-01-02"), TruncateContent(post.Content, 50))
                                                result.DeletedCount++
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// extractPostID extracts the post ID from a Bluesky URI
func extractPostID(uri string) string <span class="cov8" title="1">{
        // URI format: at://did:plc:xxx/app.bsky.feed.post/postid
        // We want just the postid part
        if len(uri) &gt; 0 </span><span class="cov8" title="1">{
                parts := []rune(uri)
                for i := len(parts) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        if parts[i] == '/' </span><span class="cov8" title="1">{
                                return string(parts[i+1:])
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

// AT Protocol session management and API types
type atpSessionResponse struct {
        AccessJwt  string `json:"accessJwt"`
        RefreshJwt string `json:"refreshJwt"`
        Handle     string `json:"handle"`
        DID        string `json:"did"`
}


// ensureValidSession ensures we have a valid session, creating/refreshing as needed
func (c *BlueskyClient) ensureValidSession(creds *Credentials) (*atpSessionResponse, error) <span class="cov8" title="1">{
        logger := WithPlatform("bluesky")
        
        // If we don't have a session or credentials changed, create new session
        if c.session == nil || c.sessionManager.HasCredentialsChanged(creds) </span><span class="cov8" title="1">{
                if c.sessionManager.HasCredentialsChanged(creds) </span><span class="cov8" title="1">{
                        logger.Debug().Msg("Credentials changed, creating new Bluesky session")
                        fmt.Printf("üîÑ Credentials changed, creating new Bluesky session...\n")
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug().Msg("Creating new Bluesky session")
                        fmt.Printf("üîê Creating new Bluesky session...\n")
                }</span>
                <span class="cov8" title="1">return c.createNewSession(creds)</span>
        }

        // If session is expired or about to expire, try to refresh
        <span class="cov0" title="0">if !c.sessionManager.IsSessionValid() </span><span class="cov0" title="0">{
                logger.Debug().Msg("Session expired, refreshing using refresh token")
                fmt.Printf("üîÑ Refreshing Bluesky session using refresh token...\n")
                refreshedSession, err := c.refreshSession()
                if err != nil </span><span class="cov0" title="0">{
                        // If refresh fails, fall back to creating a new session
                        logger.Debug().Err(err).Msg("Session refresh failed, creating new session")
                        fmt.Printf("‚ö†Ô∏è  Refresh failed, creating new session: %v\n", err)
                        return c.createNewSession(creds)
                }</span>
                <span class="cov0" title="0">return refreshedSession, nil</span>
        }

        // Reusing existing session
        <span class="cov0" title="0">logger.Debug().Msg("Reusing existing valid session")
        return c.session, nil</span>
}

// refreshSession uses the refresh token to extend the current session
func (c *BlueskyClient) refreshSession() (*atpSessionResponse, error) <span class="cov0" title="0">{
        if c.session == nil || c.session.RefreshJwt == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid refresh token available")
        }</span>

        <span class="cov0" title="0">refreshURL := "https://bsky.social/xrpc/com.atproto.server.refreshSession"

        req, err := http.NewRequest("POST", refreshURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create refresh request: %w", err)
        }</span>

        // Use the refresh token as authorization
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+c.session.RefreshJwt)
        req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        LogHTTPRequest("POST", refreshURL)
        resp, err := client.Do(req)
        LogHTTPResponse("POST", refreshURL, resp.StatusCode, resp.Status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("refresh request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("session refresh failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read refresh response: %w", err)
        }</span>

        <span class="cov0" title="0">var refreshedSession atpSessionResponse
        if err := json.Unmarshal(body, &amp;refreshedSession); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse refresh response: %w", err)
        }</span>

        // Update stored session with new tokens
        <span class="cov0" title="0">c.session = &amp;refreshedSession

        // Try to parse actual expiration from refreshed JWT, fall back to 24 hours
        logger := WithPlatform("bluesky")
        if expTime, err := c.parseJWTExpiration(refreshedSession.AccessJwt); err == nil </span><span class="cov0" title="0">{
                c.sessionManager.UpdateSession(refreshedSession.AccessJwt, refreshedSession.RefreshJwt, expTime, &amp;Credentials{})
                logger.Debug().Time("expires_at", expTime).Msg("Session refreshed with parsed expiration")
                fmt.Printf("‚úÖ Session refreshed, expires at %s\n", expTime.Format("15:04:05"))
        }</span> else<span class="cov0" title="0"> {
                // Fallback to default 24 hours
                expTime := time.Now().Add(24 * time.Hour)
                c.sessionManager.UpdateSession(refreshedSession.AccessJwt, refreshedSession.RefreshJwt, expTime, &amp;Credentials{})
                logger.Debug().Time("expires_at", expTime).Msg("Session refreshed with default 24h expiration")
                fmt.Printf("‚úÖ Session refreshed with default 24h expiration\n")
        }</span>

        <span class="cov0" title="0">return &amp;refreshedSession, nil</span>
}

// parseJWTExpiration extracts expiration time from JWT token
func (c *BlueskyClient) parseJWTExpiration(token string) (time.Time, error) <span class="cov8" title="1">{
        // JWT format: header.payload.signature
        parts := strings.Split(token, ".")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("invalid JWT format")
        }</span>

        // Decode the payload (second part)
        <span class="cov8" title="1">payload := parts[1]
        // Add padding if necessary for base64 decoding
        if len(payload)%4 != 0 </span><span class="cov8" title="1">{
                payload += strings.Repeat("=", 4-len(payload)%4)
        }</span>

        <span class="cov8" title="1">decoded, err := base64.URLEncoding.DecodeString(payload)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to decode JWT payload: %w", err)
        }</span>

        <span class="cov8" title="1">var claims struct {
                Exp int64 `json:"exp"` // Unix timestamp
        }

        if err := json.Unmarshal(decoded, &amp;claims); err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to parse JWT claims: %w", err)
        }</span>

        <span class="cov8" title="1">if claims.Exp == 0 </span><span class="cov0" title="0">{
                // No expiration in token, fall back to default
                return time.Now().Add(24 * time.Hour), nil
        }</span>

        <span class="cov8" title="1">return time.Unix(claims.Exp, 0), nil</span>
}

// createNewSession creates a fresh session and stores it
func (c *BlueskyClient) createNewSession(creds *Credentials) (*atpSessionResponse, error) <span class="cov8" title="1">{
        session, err := c.createSession(creds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store session and credentials for reuse
        <span class="cov8" title="1">c.session = session

        // Try to parse actual expiration from JWT, fall back to 24 hours
        logger := WithPlatform("bluesky")
        if expTime, err := c.parseJWTExpiration(session.AccessJwt); err == nil </span><span class="cov8" title="1">{
                c.sessionManager.UpdateSession(session.AccessJwt, session.RefreshJwt, expTime, creds)
                logger.Debug().Time("expires_at", expTime).Msg("Session created with parsed expiration")
                fmt.Printf("‚úÖ Session created, expires at %s\n", expTime.Format("15:04:05"))
        }</span> else<span class="cov0" title="0"> {
                // Fallback to default 24 hours
                expTime := time.Now().Add(24 * time.Hour)
                c.sessionManager.UpdateSession(session.AccessJwt, session.RefreshJwt, expTime, creds)
                logger.Debug().Time("expires_at", expTime).Msg("Session created with default 24h expiration")
                fmt.Printf("‚úÖ Session created with default 24h expiration\n")
        }</span>

        <span class="cov8" title="1">return session, nil</span>
}

// createSession authenticates with AT Protocol and returns access token
func (c *BlueskyClient) createSession(creds *Credentials) (*atpSessionResponse, error) <span class="cov8" title="1">{
        sessionURL := "https://bsky.social/xrpc/com.atproto.server.createSession"

        sessionData := map[string]string{
                "identifier": creds.Username,
                "password":   creds.AppPassword,
        }

        jsonData, err := json.Marshal(sessionData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal session data: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", sessionURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        LogHTTPRequest("POST", sessionURL)
        resp, err := client.Do(req)
        LogHTTPResponse("POST", sessionURL, resp.StatusCode, resp.Status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session request failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("session creation failed with status %d: %s. This may indicate invalid credentials or DID resolution issues", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read session response: %w", err)
        }</span>

        <span class="cov8" title="1">var session atpSessionResponse
        if err := json.Unmarshal(body, &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse session response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;session, nil</span>
}

// deletePost deletes a Bluesky post using AT Protocol
func (c *BlueskyClient) deletePost(creds *Credentials, postURI string) error <span class="cov0" title="0">{
        session, err := c.ensureValidSession(creds)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure valid session: %w", err)
        }</span>

        // Extract collection and rkey from URI
        // URI format: at://did:plc:xxx/app.bsky.feed.post/rkey
        <span class="cov0" title="0">parts := strings.Split(postURI, "/")
        if len(parts) &lt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid post URI format: %s", postURI)
        }</span>

        <span class="cov0" title="0">did := parts[2]
        collection := strings.Join(parts[3:len(parts)-1], "/")
        rkey := parts[len(parts)-1]

        // Verify that the DID from the post URI matches the authenticated user's DID
        if did != session.DID </span><span class="cov0" title="0">{
                return fmt.Errorf("DID mismatch: post DID %s does not match authenticated user DID %s. This suggests the post belongs to a different user or there's a DID resolution issue", did, session.DID)
        }</span>

        <span class="cov0" title="0">deleteURL := "https://bsky.social/xrpc/com.atproto.repo.deleteRecord"

        deleteData := map[string]string{
                "repo":       session.DID, // Use authenticated user's DID instead of post DID
                "collection": collection,
                "rkey":       rkey,
        }

        jsonData, err := json.Marshal(deleteData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal delete data: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", deleteURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create delete request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+session.AccessJwt)
        req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        LogHTTPRequest("POST", deleteURL)
        resp, err := client.Do(req)
        LogHTTPResponse("POST", deleteURL, resp.StatusCode, resp.Status)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("delete request failed with status %d: %s. DID used: %s, rkey: %s", resp.StatusCode, string(body), session.DID, rkey)
        }</span>

        <span class="cov0" title="0">return nil</span>
}



// findLikeRecord finds the rkey for a like record of a specific post
func (c *BlueskyClient) findLikeRecord(session *atpSessionResponse, postURI string) (string, error) <span class="cov0" title="0">{
        listURL := "https://bsky.social/xrpc/com.atproto.repo.listRecords"

        params := url.Values{}
        params.Add("repo", session.DID)
        params.Add("collection", "app.bsky.feed.like")
        params.Add("limit", "100") // Start with reasonable limit

        var cursor string

        for </span><span class="cov0" title="0">{
                currentParams := url.Values{}
                for k, v := range params </span><span class="cov0" title="0">{
                        currentParams[k] = v
                }</span>
                <span class="cov0" title="0">if cursor != "" </span><span class="cov0" title="0">{
                        currentParams.Add("cursor", cursor)
                }</span>

                <span class="cov0" title="0">fullURL := fmt.Sprintf("%s?%s", listURL, currentParams.Encode())

                req, err := http.NewRequest("GET", fullURL, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to create list request: %w", err)
                }</span>

                <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+session.AccessJwt)

                client := &amp;http.Client{Timeout: 30 * time.Second}
                LogHTTPRequest("GET", fullURL)
                resp, err := client.Do(req)
                LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("list request failed: %w", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        body, _ := io.ReadAll(resp.Body)
                        return "", fmt.Errorf("list request failed with status %d: %s", resp.StatusCode, string(body))
                }</span>

                <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read list response: %w", err)
                }</span>

                <span class="cov0" title="0">var listResponse struct {
                        Records []struct {
                                URI   string `json:"uri"`
                                Value struct {
                                        Subject struct {
                                                URI string `json:"uri"`
                                        } `json:"subject"`
                                } `json:"value"`
                        } `json:"records"`
                        Cursor *string `json:"cursor,omitempty"`
                }

                if err := json.Unmarshal(body, &amp;listResponse); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to parse list response: %w", err)
                }</span>

                // Search for like record matching the post URI
                <span class="cov0" title="0">for _, record := range listResponse.Records </span><span class="cov0" title="0">{
                        if record.Value.Subject.URI == postURI </span><span class="cov0" title="0">{
                                // Extract rkey from like record URI
                                parts := strings.Split(record.URI, "/")
                                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                        return parts[len(parts)-1], nil
                                }</span>
                        }
                }

                // If there's no cursor, we've reached the end
                <span class="cov0" title="0">if listResponse.Cursor == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">cursor = *listResponse.Cursor</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no like record found for post %s", postURI)</span>
}

// findRepostRecord finds the rkey for a repost record of a specific post
func (c *BlueskyClient) findRepostRecord(session *atpSessionResponse, postURI string) (string, error) <span class="cov0" title="0">{
        listURL := "https://bsky.social/xrpc/com.atproto.repo.listRecords"

        params := url.Values{}
        params.Add("repo", session.DID)
        params.Add("collection", "app.bsky.feed.repost")
        params.Add("limit", "100") // Start with reasonable limit

        var cursor string

        for </span><span class="cov0" title="0">{
                currentParams := url.Values{}
                for k, v := range params </span><span class="cov0" title="0">{
                        currentParams[k] = v
                }</span>
                <span class="cov0" title="0">if cursor != "" </span><span class="cov0" title="0">{
                        currentParams.Add("cursor", cursor)
                }</span>

                <span class="cov0" title="0">fullURL := fmt.Sprintf("%s?%s", listURL, currentParams.Encode())

                req, err := http.NewRequest("GET", fullURL, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to create list request: %w", err)
                }</span>

                <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+session.AccessJwt)

                client := &amp;http.Client{Timeout: 30 * time.Second}
                LogHTTPRequest("GET", fullURL)
                resp, err := client.Do(req)
                LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("list request failed: %w", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        body, _ := io.ReadAll(resp.Body)
                        return "", fmt.Errorf("list request failed with status %d: %s", resp.StatusCode, string(body))
                }</span>

                <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read list response: %w", err)
                }</span>

                <span class="cov0" title="0">var listResponse struct {
                        Records []struct {
                                URI   string `json:"uri"`
                                Value struct {
                                        Subject struct {
                                                URI string `json:"uri"`
                                        } `json:"subject"`
                                } `json:"value"`
                        } `json:"records"`
                        Cursor *string `json:"cursor,omitempty"`
                }

                if err := json.Unmarshal(body, &amp;listResponse); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to parse list response: %w", err)
                }</span>

                // Search for repost record matching the post URI
                <span class="cov0" title="0">for _, record := range listResponse.Records </span><span class="cov0" title="0">{
                        if record.Value.Subject.URI == postURI </span><span class="cov0" title="0">{
                                // Extract rkey from repost record URI
                                parts := strings.Split(record.URI, "/")
                                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                        return parts[len(parts)-1], nil
                                }</span>
                        }
                }

                // If there's no cursor, we've reached the end
                <span class="cov0" title="0">if listResponse.Cursor == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">cursor = *listResponse.Cursor</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no repost record found for post %s", postURI)</span>
}


// validatePostURI validates that a post URI belongs to the authenticated user
func (c *BlueskyClient) validatePostURI(postURI string, userDID string) error <span class="cov0" title="0">{
        parts := strings.Split(postURI, "/")
        if len(parts) &lt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid post URI format: %s", postURI)
        }</span>

        <span class="cov0" title="0">postDID := parts[2]
        if postDID != userDID </span><span class="cov0" title="0">{
                return fmt.Errorf("post DID %s does not match authenticated user DID %s", postDID, userDID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// fetchRepostPosts fetches the user's own repost records
func (c *BlueskyClient) fetchRepostPosts(session *atpSessionResponse, limit int) ([]Post, error) <span class="cov0" title="0">{
        listURL := "https://bsky.social/xrpc/com.atproto.repo.listRecords"

        params := url.Values{}
        params.Add("repo", session.DID)
        params.Add("collection", "app.bsky.feed.repost")
        params.Add("limit", fmt.Sprintf("%d", limit))

        fullURL := fmt.Sprintf("%s?%s", listURL, params.Encode())

        req, err := http.NewRequest("GET", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create list request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+session.AccessJwt)

        client := &amp;http.Client{Timeout: 30 * time.Second}
        LogHTTPRequest("GET", fullURL)
        resp, err := client.Do(req)
        LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("list request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read list response: %w", err)
        }</span>

        <span class="cov0" title="0">var listResponse struct {
                Records []struct {
                        URI   string `json:"uri"`
                        Value struct {
                                Subject struct {
                                        URI string `json:"uri"`
                                } `json:"subject"`
                                CreatedAt time.Time `json:"createdAt"`
                        } `json:"value"`
                } `json:"records"`
        }

        if err := json.Unmarshal(body, &amp;listResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse list response: %w", err)
        }</span>

        <span class="cov0" title="0">var repostPosts []Post
        for _, record := range listResponse.Records </span><span class="cov0" title="0">{
                post := Post{
                        ID:        record.URI, // This is the repost record URI, not the original post
                        Type:      PostTypeRepost,
                        Platform:  "bluesky",
                        CreatedAt: record.Value.CreatedAt,
                        Content:   fmt.Sprintf("Reposted: %s", record.Value.Subject.URI), // Show what was reposted
                }
                repostPosts = append(repostPosts, post)
        }</span>

        <span class="cov0" title="0">return repostPosts, nil</span>
}

// fetchLikedPosts fetches posts that the user has liked
func (c *BlueskyClient) fetchLikedPosts(session *atpSessionResponse, limit int) ([]Post, error) <span class="cov0" title="0">{
        listURL := "https://bsky.social/xrpc/com.atproto.repo.listRecords"

        params := url.Values{}
        params.Add("repo", session.DID)
        params.Add("collection", "app.bsky.feed.like")
        params.Add("limit", fmt.Sprintf("%d", limit))

        fullURL := fmt.Sprintf("%s?%s", listURL, params.Encode())

        req, err := http.NewRequest("GET", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create list request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+session.AccessJwt)

        client := &amp;http.Client{Timeout: 30 * time.Second}
        LogHTTPRequest("GET", fullURL)
        resp, err := client.Do(req)
        LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("list request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read list response: %w", err)
        }</span>

        <span class="cov0" title="0">var listResponse struct {
                Records []struct {
                        URI   string `json:"uri"`
                        Value struct {
                                Subject struct {
                                        URI string `json:"uri"`
                                } `json:"subject"`
                                CreatedAt time.Time `json:"createdAt"`
                        } `json:"value"`
                } `json:"records"`
        }

        if err := json.Unmarshal(body, &amp;listResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse list response: %w", err)
        }</span>

        <span class="cov0" title="0">var likedPosts []Post
        for _, record := range listResponse.Records </span><span class="cov0" title="0">{
                post := Post{
                        ID:        record.URI, // This is the like record URI, not the original post
                        Type:      PostTypeLike,
                        Platform:  "bluesky",
                        CreatedAt: record.Value.CreatedAt,
                        Content:   fmt.Sprintf("Liked: %s", record.Value.Subject.URI), // Show what was liked
                }
                likedPosts = append(likedPosts, post)
        }</span>

        <span class="cov0" title="0">return likedPosts, nil</span>
}

// deleteLikeRecord deletes a like record directly
func (c *BlueskyClient) deleteLikeRecord(creds *Credentials, likeURI string) error <span class="cov0" title="0">{
        session, err := c.ensureValidSession(creds)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure valid session: %w", err)
        }</span>

        // Extract collection and rkey from like URI
        // URI format: at://did:plc:xxx/app.bsky.feed.like/rkey
        <span class="cov0" title="0">parts := strings.Split(likeURI, "/")
        if len(parts) &lt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid like URI format: %s", likeURI)
        }</span>

        <span class="cov0" title="0">did := parts[2]
        collection := strings.Join(parts[3:len(parts)-1], "/")
        rkey := parts[len(parts)-1]

        // Verify that the DID from the like URI matches the authenticated user's DID
        if did != session.DID </span><span class="cov0" title="0">{
                return fmt.Errorf("DID mismatch: like DID %s does not match authenticated user DID %s", did, session.DID)
        }</span>

        <span class="cov0" title="0">deleteURL := "https://bsky.social/xrpc/com.atproto.repo.deleteRecord"

        deleteData := map[string]string{
                "repo":       session.DID,
                "collection": collection,
                "rkey":       rkey,
        }

        jsonData, err := json.Marshal(deleteData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal delete data: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", deleteURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create delete request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+session.AccessJwt)
        req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        LogHTTPRequest("POST", deleteURL)
        resp, err := client.Do(req)
        LogHTTPResponse("POST", deleteURL, resp.StatusCode, resp.Status)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("delete like failed with status %d: %s. DID used: %s, rkey: %s", resp.StatusCode, string(body), session.DID, rkey)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// deleteRepostRecord deletes a repost record directly (simpler than unrepost)
func (c *BlueskyClient) deleteRepostRecord(creds *Credentials, repostURI string) error <span class="cov0" title="0">{
        session, err := c.ensureValidSession(creds)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure valid session: %w", err)
        }</span>

        // Extract collection and rkey from repost URI
        // URI format: at://did:plc:xxx/app.bsky.feed.repost/rkey
        <span class="cov0" title="0">parts := strings.Split(repostURI, "/")
        if len(parts) &lt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repost URI format: %s", repostURI)
        }</span>

        <span class="cov0" title="0">did := parts[2]
        collection := strings.Join(parts[3:len(parts)-1], "/")
        rkey := parts[len(parts)-1]

        // Verify that the DID from the repost URI matches the authenticated user's DID
        if did != session.DID </span><span class="cov0" title="0">{
                return fmt.Errorf("DID mismatch: repost DID %s does not match authenticated user DID %s", did, session.DID)
        }</span>

        <span class="cov0" title="0">deleteURL := "https://bsky.social/xrpc/com.atproto.repo.deleteRecord"

        deleteData := map[string]string{
                "repo":       session.DID,
                "collection": collection,
                "rkey":       rkey,
        }

        jsonData, err := json.Marshal(deleteData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal delete data: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", deleteURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create delete request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+session.AccessJwt)
        req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        LogHTTPRequest("POST", deleteURL)
        resp, err := client.Do(req)
        LogHTTPResponse("POST", deleteURL, resp.StatusCode, resp.Status)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("delete repost failed with status %d: %s. DID used: %s, rkey: %s", resp.StatusCode, string(body), session.DID, rkey)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package internal

import (
        "fmt"
        "os"
)

// GetCredentialsForPlatform attempts to load credentials using multiple fallback methods
func GetCredentialsForPlatform(platform string) (*Credentials, error) <span class="cov8" title="1">{
        // First, try to load from saved config files
        authManager, err := NewAuthManager()
        if err == nil </span><span class="cov8" title="1">{
                if creds, err := authManager.LoadCredentials(platform); err == nil </span><span class="cov8" title="1">{
                        if err := ValidateCredentials(creds); err == nil </span><span class="cov8" title="1">{
                                return creds, nil
                        }</span>
                }
        }

        // Second, try to load from environment variables
        <span class="cov0" title="0">if creds := GetCredentialsFromEnv(platform); creds != nil </span><span class="cov0" title="0">{
                if err := ValidateCredentials(creds); err == nil </span><span class="cov0" title="0">{
                        return creds, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no valid credentials found for platform %s. Run 'cringesweeper auth --platforms=%s' to set up authentication", platform, platform)</span>
}

// GetUsernameForPlatform gets username with fallback priority: argument &gt; saved credentials &gt; environment
func GetUsernameForPlatform(platform string, argUsername string) (string, error) <span class="cov8" title="1">{
        // If username provided as argument, use it
        if argUsername != "" </span><span class="cov8" title="1">{
                return argUsername, nil
        }</span>

        // Try to get username from saved credentials
        <span class="cov8" title="1">authManager, err := NewAuthManager()
        if err == nil </span><span class="cov8" title="1">{
                if creds, err := authManager.LoadCredentials(platform); err == nil </span><span class="cov8" title="1">{
                        if creds.Username != "" </span><span class="cov8" title="1">{
                                return creds.Username, nil
                        }</span>
                }
        }

        // Fallback to environment variables
        <span class="cov8" title="1">switch platform </span>{
        case "bluesky":<span class="cov0" title="0">
                if username := os.Getenv("BLUESKY_USER"); username != "" </span><span class="cov0" title="0">{
                        return username, nil
                }</span>
        case "mastodon":<span class="cov0" title="0">
                if username := os.Getenv("MASTODON_USER"); username != "" </span><span class="cov0" title="0">{
                        return username, nil
                }</span>
        }

        // Final fallback to generic environment variable
        <span class="cov8" title="1">if username := os.Getenv("SOCIAL_USER"); username != "" </span><span class="cov0" title="0">{
                return username, nil
        }</span>

        <span class="cov8" title="1">return "", fmt.Errorf("no username found. Please provide a username as an argument, run 'cringesweeper auth --platforms=%s', or set %s_USER environment variable", platform, map[string]string{"bluesky": "BLUESKY", "mastodon": "MASTODON"}[platform])</span>
}

// GetCredentialsForPlatformEnvOnly only loads credentials from environment variables (for server mode)
func GetCredentialsForPlatformEnvOnly(platform string) (*Credentials, error) <span class="cov0" title="0">{
        creds := GetCredentialsFromEnv(platform)
        if creds == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no credentials found in environment variables for platform %s. In server mode, credentials must be provided via environment variables", platform)
        }</span>
        
        <span class="cov0" title="0">if err := ValidateCredentials(creds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid credentials from environment variables for platform %s: %w", platform, err)
        }</span>
        
        <span class="cov0" title="0">return creds, nil</span>
}

// GetUsernameForPlatformEnvOnly gets username from environment variables only (for server mode)
func GetUsernameForPlatformEnvOnly(platform string, argUsername string) (string, error) <span class="cov0" title="0">{
        // If username provided as argument, use it
        if argUsername != "" </span><span class="cov0" title="0">{
                return argUsername, nil
        }</span>

        // Only try environment variables (no saved credentials in server mode)
        <span class="cov0" title="0">switch platform </span>{
        case "bluesky":<span class="cov0" title="0">
                if username := os.Getenv("BLUESKY_USER"); username != "" </span><span class="cov0" title="0">{
                        return username, nil
                }</span>
                <span class="cov0" title="0">if username := os.Getenv("BLUESKY_USERNAME"); username != "" </span><span class="cov0" title="0">{
                        return username, nil
                }</span>
        case "mastodon":<span class="cov0" title="0">
                if username := os.Getenv("MASTODON_USER"); username != "" </span><span class="cov0" title="0">{
                        return username, nil
                }</span>
                <span class="cov0" title="0">if username := os.Getenv("MASTODON_USERNAME"); username != "" </span><span class="cov0" title="0">{
                        return username, nil
                }</span>
        }

        // Final fallback to generic environment variable
        <span class="cov0" title="0">if username := os.Getenv("SOCIAL_USER"); username != "" </span><span class="cov0" title="0">{
                return username, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("no username found in environment variables. In server mode, please provide a username as an argument or set %s_USERNAME environment variable", map[string]string{"bluesky": "BLUESKY", "mastodon": "MASTODON"}[platform])</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package internal

import (
        "os"
        "regexp"
        "strings"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// Logger provides a global logger instance for the application
var Logger zerolog.Logger

// InitLogger initializes the global logger with appropriate configuration
// Uses LOG_LEVEL environment variable, defaulting to INFO
func InitLogger() <span class="cov0" title="0">{
        // Configure log level from environment, default to INFO
        logLevel := strings.ToUpper(os.Getenv("LOG_LEVEL"))
        if logLevel == "" </span><span class="cov0" title="0">{
                logLevel = "INFO"
        }</span>
        <span class="cov0" title="0">InitLoggerWithLevel(logLevel)</span>
}

// InitLoggerWithLevel initializes the global logger with a specific log level
func InitLoggerWithLevel(logLevelStr string) <span class="cov0" title="0">{
        logLevel := strings.ToUpper(logLevelStr)
        var level zerolog.Level
        
        switch logLevel </span>{
        case "DEBUG":<span class="cov0" title="0">
                level = zerolog.DebugLevel</span>
        case "INFO":<span class="cov0" title="0">
                level = zerolog.InfoLevel</span>
        case "WARN":<span class="cov0" title="0">
                level = zerolog.WarnLevel</span>
        case "ERROR":<span class="cov0" title="0">
                level = zerolog.ErrorLevel</span>
        default:<span class="cov0" title="0">
                level = zerolog.InfoLevel</span>
        }

        // Configure console output with colors if in terminal
        <span class="cov0" title="0">output := zerolog.ConsoleWriter{Out: os.Stdout}
        output.TimeFormat = "15:04:05"
        
        // Create logger with timestamp and level
        Logger = zerolog.New(output).
                Level(level).
                With().
                Timestamp().
                Logger()
        
        // Also set the global log package logger
        log.Logger = Logger
        
        Logger.Debug().
                Str("level", level.String()).
                Msg("Logger initialized")</span>
}

// GetLogger returns the configured logger instance
func GetLogger() *zerolog.Logger <span class="cov0" title="0">{
        return &amp;Logger
}</span>

// WithPlatform creates a logger with platform context
func WithPlatform(platform string) *zerolog.Logger <span class="cov8" title="1">{
        logger := Logger.With().Str("platform", platform).Logger()
        return &amp;logger
}</span>

// WithHTTP creates a logger with HTTP context
func WithHTTP(method, url string) *zerolog.Logger <span class="cov0" title="0">{
        redactedURL := RedactSensitiveURL(url)
        logger := Logger.With().
                Str("http_method", method).
                Str("url", redactedURL).
                Logger()
        return &amp;logger
}</span>

// RedactSensitiveURL redacts sensitive information from URLs for logging
func RedactSensitiveURL(url string) string <span class="cov8" title="1">{
        // Redact Authorization tokens and passwords in query params
        re := regexp.MustCompile(`([?&amp;])(password|token|access_token|refresh_token|bearer|authorization)=([^&amp;]+)`)
        url = re.ReplaceAllString(url, "${1}${2}=***REDACTED***")
        
        // Redact any potential tokens in path segments (like JWT tokens)
        re = regexp.MustCompile(`/eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+`)
        url = re.ReplaceAllString(url, "/***JWT_TOKEN***")
        
        // Redact anything that looks like an app password (typically long alphanumeric strings)
        re = regexp.MustCompile(`([?&amp;])(app[_-]?password|apppassword)=([^&amp;]+)`)
        url = re.ReplaceAllString(url, "${1}${2}=***REDACTED***")
        
        return url
}</span>

// WithOperation creates a logger with operation context
func WithOperation(operation string) *zerolog.Logger <span class="cov0" title="0">{
        logger := Logger.With().Str("operation", operation).Logger()
        return &amp;logger
}</span>

// LogHTTPRequest logs an HTTP request at DEBUG level with full URL and redaction
func LogHTTPRequest(method, url string) <span class="cov8" title="1">{
        redactedURL := RedactSensitiveURL(url)
        Logger.Debug().
                Str("http_method", method).
                Str("url", redactedURL).
                Msg("Making HTTP request")
}</span>

// LogHTTPResponse logs an HTTP response at DEBUG level
func LogHTTPResponse(method, url string, statusCode int, status string) <span class="cov8" title="1">{
        redactedURL := RedactSensitiveURL(url)
        Logger.Debug().
                Str("http_method", method).
                Str("url", redactedURL).
                Int("status_code", statusCode).
                Str("status", status).
                Msg("HTTP request completed")
}</pre>
		
		<pre class="file" id="file11" style="display: none">package internal

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"
)

// MastodonClient implements the SocialClient interface for Mastodon
type MastodonClient struct {
        sessionManager      *SessionManager
        authenticatedClient *AuthenticatedHTTPClient
        instanceURL         string
}

// NewMastodonClient creates a new Mastodon client
func NewMastodonClient() *MastodonClient <span class="cov8" title="1">{
        return &amp;MastodonClient{
                sessionManager: NewSessionManager("mastodon"),
        }
}</span>

// GetPlatformName returns the platform name
func (c *MastodonClient) GetPlatformName() string <span class="cov8" title="1">{
        return "Mastodon"
}</span>

// RequiresAuth returns true if the platform requires authentication for deletion
func (c *MastodonClient) RequiresAuth() bool <span class="cov8" title="1">{
        return true // Mastodon requires authentication for post deletion
}</span>

// FetchUserPosts retrieves recent posts for a Mastodon user
func (c *MastodonClient) FetchUserPosts(username string, limit int) ([]Post, error) <span class="cov8" title="1">{
        instanceURL, acct, err := c.parseUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid username format: %w", err)
        }</span>

        // First, get the account ID
        <span class="cov8" title="1">accountID, err := c.getAccountID(instanceURL, acct)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get account ID: %w", err)
        }</span>

        // Check if we have authentication for enhanced data
        <span class="cov8" title="1">var statuses []mastodonStatus
        creds, authErr := GetCredentialsForPlatform("mastodon")
        if authErr == nil &amp;&amp; ValidateCredentials(creds) == nil </span><span class="cov8" title="1">{
                // Use authenticated fetch for viewer interaction data
                statuses, err = c.fetchUserStatusesAuthenticated(instanceURL, accountID, limit, creds)
        }</span> else<span class="cov0" title="0"> {
                // Use public fetch without viewer data
                statuses, err = c.fetchUserStatuses(instanceURL, accountID, limit)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch statuses: %w", err)
        }</span>

        // Convert to generic Post format
        <span class="cov8" title="1">var posts []Post
        for _, status := range statuses </span><span class="cov8" title="1">{
                post := Post{
                        ID:        status.ID,
                        Author:    status.Account.DisplayName,
                        Handle:    status.Account.Acct,
                        Content:   c.stripHTML(status.Content),
                        CreatedAt: status.CreatedAt,
                        URL:       status.URL,
                        Type:      c.determinePostType(status),
                        Platform:  "mastodon",

                        // Engagement metrics
                        RepostCount: status.ReblogsCount,
                        LikeCount:   status.FavouritesCount,
                        ReplyCount:  status.RepliesCount,

                        // Viewer interaction status
                        IsLikedByUser: status.Favourited != nil &amp;&amp; *status.Favourited,
                        IsPinned:      status.Pinned != nil &amp;&amp; *status.Pinned,
                }

                // Handle reblogs/reposts
                if status.Reblog != nil </span><span class="cov0" title="0">{
                        post.Type = PostTypeRepost
                        // IMPORTANT: For reblogs, post.ID should be the reblog status ID (for unrebogging)
                        // status.ID is the reblog action ID, status.Reblog.ID is the original post ID
                        post.ID = status.ID // This is the reblog action ID we need to unreblog
                        post.OriginalAuthor = status.Reblog.Account.DisplayName
                        post.OriginalHandle = status.Reblog.Account.Acct
                        post.Content = c.stripHTML(status.Reblog.Content)
                        // Create embedded original post
                        post.OriginalPost = &amp;Post{
                                ID:        status.Reblog.ID, // Original post ID
                                Author:    status.Reblog.Account.DisplayName,
                                Handle:    status.Reblog.Account.Acct,
                                Content:   c.stripHTML(status.Reblog.Content),
                                CreatedAt: status.Reblog.CreatedAt,
                                URL:       status.Reblog.URL,
                                Type:      PostTypeOriginal,
                                Platform:  "mastodon",
                        }
                }</span>

                // Handle replies
                <span class="cov8" title="1">if status.InReplyToID != nil </span><span class="cov0" title="0">{
                        post.Type = PostTypeReply
                        post.InReplyToID = *status.InReplyToID
                        if status.InReplyToAccountID != nil </span>{<span class="cov0" title="0">
                                // We'd need additional API call to get the account info
                                // For now, just store the ID
                        }</span>
                }

                <span class="cov8" title="1">posts = append(posts, post)</span>
        }

        <span class="cov8" title="1">return posts, nil</span>
}

// FetchUserPostsPaginated retrieves posts with pagination support using max_id
func (c *MastodonClient) FetchUserPostsPaginated(username string, limit int, cursor string) ([]Post, string, error) <span class="cov0" title="0">{
        instanceURL, acct, err := c.parseUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("invalid username format: %w", err)
        }</span>

        // First, get the account ID
        <span class="cov0" title="0">accountID, err := c.getAccountID(instanceURL, acct)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get account ID: %w", err)
        }</span>

        // Check if we have authentication for enhanced data
        <span class="cov0" title="0">var statuses []mastodonStatus
        var nextCursor string
        creds, authErr := GetCredentialsForPlatform("mastodon")
        if authErr == nil &amp;&amp; ValidateCredentials(creds) == nil </span><span class="cov0" title="0">{
                // Use authenticated fetch for viewer interaction data
                statuses, nextCursor, err = c.fetchUserStatusesPaginated(instanceURL, accountID, limit, cursor, creds)
        }</span> else<span class="cov0" title="0"> {
                // Use public fetch without viewer data
                statuses, nextCursor, err = c.fetchUserStatusesPaginatedPublic(instanceURL, accountID, limit, cursor)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to fetch statuses: %w", err)
        }</span>

        // Convert to generic Post format (same logic as FetchUserPosts)
        <span class="cov0" title="0">var posts []Post
        for _, status := range statuses </span><span class="cov0" title="0">{
                post := Post{
                        ID:        status.ID,
                        Author:    status.Account.DisplayName,
                        Handle:    status.Account.Acct,
                        Content:   c.stripHTML(status.Content),
                        CreatedAt: status.CreatedAt,
                        URL:       status.URL,
                        Type:      c.determinePostType(status),
                        Platform:  "mastodon",

                        // Engagement metrics
                        RepostCount: status.ReblogsCount,
                        LikeCount:   status.FavouritesCount,
                        ReplyCount:  status.RepliesCount,

                        // Viewer interaction status
                        IsLikedByUser: status.Favourited != nil &amp;&amp; *status.Favourited,
                        IsPinned:      status.Pinned != nil &amp;&amp; *status.Pinned,
                }

                // Handle reblogs/reposts
                if status.Reblog != nil </span><span class="cov0" title="0">{
                        post.Type = PostTypeRepost
                        // IMPORTANT: For reblogs, post.ID should be the reblog status ID (for unrebogging)
                        // status.ID is the reblog action ID, status.Reblog.ID is the original post ID
                        post.ID = status.ID // This is the reblog action ID we need to unreblog
                        post.OriginalAuthor = status.Reblog.Account.DisplayName
                        post.OriginalHandle = status.Reblog.Account.Acct
                        post.Content = c.stripHTML(status.Reblog.Content)
                        // Create embedded original post
                        post.OriginalPost = &amp;Post{
                                ID:        status.Reblog.ID, // Original post ID
                                Author:    status.Reblog.Account.DisplayName,
                                Handle:    status.Reblog.Account.Acct,
                                Content:   c.stripHTML(status.Reblog.Content),
                                CreatedAt: status.Reblog.CreatedAt,
                                URL:       status.Reblog.URL,
                                Type:      PostTypeOriginal,
                                Platform:  "mastodon",
                        }
                }</span>

                // Handle replies
                <span class="cov0" title="0">if status.InReplyToID != nil </span><span class="cov0" title="0">{
                        post.Type = PostTypeReply
                        post.InReplyToID = *status.InReplyToID
                        if status.InReplyToAccountID != nil </span>{<span class="cov0" title="0">
                                // We'd need additional API call to get the account info
                                // For now, just store the ID
                        }</span>
                }

                <span class="cov0" title="0">posts = append(posts, post)</span>
        }

        <span class="cov0" title="0">return posts, nextCursor, nil</span>
}

func (c *MastodonClient) fetchUserStatusesPaginatedPublic(instanceURL, accountID string, limit int, maxID string) ([]mastodonStatus, string, error) <span class="cov0" title="0">{
        statusesURL := fmt.Sprintf("%s/api/v1/accounts/%s/statuses", instanceURL, accountID)

        params := url.Values{}
        params.Add("limit", strconv.Itoa(limit))
        params.Add("exclude_replies", "true")
        // Include reblogs so we can manage the user's own reblog actions
        params.Add("exclude_reblogs", "false")
        
        if maxID != "" </span><span class="cov0" title="0">{
                params.Add("max_id", maxID)
        }</span>

        <span class="cov0" title="0">fullURL := fmt.Sprintf("%s?%s", statusesURL, params.Encode())

        LogHTTPRequest("GET", fullURL)
        resp, err := http.Get(fullURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to fetch statuses: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, "", fmt.Errorf("statuses request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to read statuses response: %w", err)
        }</span>

        <span class="cov0" title="0">var statuses []mastodonStatus
        if err := json.Unmarshal(body, &amp;statuses); err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to parse statuses response: %w", err)
        }</span>

        // Determine next cursor from Link header or last status ID
        <span class="cov0" title="0">nextCursor := ""
        if len(statuses) &gt; 0 </span><span class="cov0" title="0">{
                // Use the ID of the last status as the max_id for the next request
                nextCursor = statuses[len(statuses)-1].ID
        }</span>

        <span class="cov0" title="0">return statuses, nextCursor, nil</span>
}

func (c *MastodonClient) fetchUserStatusesPaginated(instanceURL, accountID string, limit int, maxID string, creds *Credentials) ([]mastodonStatus, string, error) <span class="cov0" title="0">{
        statusesURL := fmt.Sprintf("%s/api/v1/accounts/%s/statuses", instanceURL, accountID)

        params := url.Values{}
        params.Add("limit", strconv.Itoa(limit))
        params.Add("exclude_replies", "true")
        // Include reblogs so we can manage the user's own reblog actions
        params.Add("exclude_reblogs", "false")
        
        if maxID != "" </span><span class="cov0" title="0">{
                params.Add("max_id", maxID)
        }</span>

        <span class="cov0" title="0">fullURL := fmt.Sprintf("%s?%s", statusesURL, params.Encode())

        req, err := http.NewRequest("GET", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add authentication header
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+creds.AccessToken)

        LogHTTPRequest("GET", fullURL)
        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to fetch statuses: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, "", fmt.Errorf("statuses request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to read statuses response: %w", err)
        }</span>

        <span class="cov0" title="0">var statuses []mastodonStatus
        if err := json.Unmarshal(body, &amp;statuses); err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to parse statuses response: %w", err)
        }</span>

        // Determine next cursor from last status ID
        <span class="cov0" title="0">nextCursor := ""
        if len(statuses) &gt; 0 </span><span class="cov0" title="0">{
                // Use the ID of the last status as the max_id for the next request
                nextCursor = statuses[len(statuses)-1].ID
        }</span>

        <span class="cov0" title="0">return statuses, nextCursor, nil</span>
}

// parseUsername extracts instance URL and account from username
// Supports formats: user@instance.social or just user (assumes MASTODON_INSTANCE env var)
func (c *MastodonClient) parseUsername(username string) (instanceURL, acct string, err error) <span class="cov8" title="1">{
        if strings.Contains(username, "@") </span><span class="cov8" title="1">{
                parts := strings.Split(username, "@")
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        return "", "", fmt.Errorf("username must be in format user@instance.social")
                }</span>
                <span class="cov8" title="1">acct = parts[0]
                instanceURL = "https://" + parts[1]</span>
        } else<span class="cov8" title="1"> {
                // Just username provided, need instance from environment or default
                acct = username
                instanceURL = "https://mastodon.social" // Default instance
        }</span>

        <span class="cov8" title="1">return instanceURL, acct, nil</span>
}

// Mastodon API types
type mastodonAccount struct {
        ID          string `json:"id"`
        Username    string `json:"username"`
        Acct        string `json:"acct"`
        DisplayName string `json:"display_name"`
}

type mastodonStatus struct {
        ID                 string          `json:"id"`
        URL                string          `json:"url"`
        Content            string          `json:"content"`
        CreatedAt          time.Time       `json:"created_at"`
        Account            mastodonAccount `json:"account"`
        InReplyToID        *string         `json:"in_reply_to_id"`
        InReplyToAccountID *string         `json:"in_reply_to_account_id"`
        Reblog             *mastodonStatus `json:"reblog"`
        ReblogsCount       int             `json:"reblogs_count"`
        FavouritesCount    int             `json:"favourites_count"`
        RepliesCount       int             `json:"replies_count"`

        // Viewer interaction fields
        Favourited *bool `json:"favourited,omitempty"` // Whether the authenticated user has favorited this status
        Reblogged  *bool `json:"reblogged,omitempty"`  // Whether the authenticated user has reblogged this status
        Pinned     *bool `json:"pinned,omitempty"`     // Whether this is a pinned status
}

// getAccountID looks up account ID by username
func (c *MastodonClient) getAccountID(instanceURL, acct string) (string, error) <span class="cov8" title="1">{
        lookupURL := fmt.Sprintf("%s/api/v1/accounts/lookup", instanceURL)

        params := url.Values{}
        params.Add("acct", acct)

        fullURL := fmt.Sprintf("%s?%s", lookupURL, params.Encode())

        LogHTTPRequest("GET", fullURL)
        resp, err := http.Get(fullURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to lookup account: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("account lookup failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read lookup response: %w", err)
        }</span>

        <span class="cov8" title="1">var account mastodonAccount
        if err := json.Unmarshal(body, &amp;account); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse account response: %w", err)
        }</span>

        <span class="cov8" title="1">return account.ID, nil</span>
}

// fetchUserStatuses gets statuses for an account ID
func (c *MastodonClient) fetchUserStatuses(instanceURL, accountID string, limit int) ([]mastodonStatus, error) <span class="cov0" title="0">{
        statusesURL := fmt.Sprintf("%s/api/v1/accounts/%s/statuses", instanceURL, accountID)

        params := url.Values{}
        params.Add("limit", strconv.Itoa(limit))
        params.Add("exclude_replies", "true")
        // Include reblogs so we can manage the user's own reblog actions
        params.Add("exclude_reblogs", "false")

        fullURL := fmt.Sprintf("%s?%s", statusesURL, params.Encode())

        LogHTTPRequest("GET", fullURL)
        resp, err := http.Get(fullURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch statuses: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("statuses request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read statuses response: %w", err)
        }</span>

        <span class="cov0" title="0">var statuses []mastodonStatus
        if err := json.Unmarshal(body, &amp;statuses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse statuses response: %w", err)
        }</span>

        <span class="cov0" title="0">return statuses, nil</span>
}

// fetchUserStatusesAuthenticated gets statuses with viewer interaction data
func (c *MastodonClient) fetchUserStatusesAuthenticated(instanceURL, accountID string, limit int, creds *Credentials) ([]mastodonStatus, error) <span class="cov8" title="1">{
        statusesURL := fmt.Sprintf("%s/api/v1/accounts/%s/statuses", instanceURL, accountID)

        params := url.Values{}
        params.Add("limit", strconv.Itoa(limit))
        params.Add("exclude_replies", "true")
        // Include reblogs so we can manage the user's own reblog actions
        params.Add("exclude_reblogs", "false")

        fullURL := fmt.Sprintf("%s?%s", statusesURL, params.Encode())

        req, err := http.NewRequest("GET", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add authentication header
        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+creds.AccessToken)

        LogHTTPRequest("GET", fullURL)
        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch statuses: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        LogHTTPResponse("GET", fullURL, resp.StatusCode, resp.Status)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("statuses request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read statuses response: %w", err)
        }</span>

        <span class="cov8" title="1">var statuses []mastodonStatus
        if err := json.Unmarshal(body, &amp;statuses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse statuses response: %w", err)
        }</span>

        <span class="cov8" title="1">return statuses, nil</span>
}

// stripHTML removes HTML tags from content (basic implementation)
func (c *MastodonClient) stripHTML(content string) string <span class="cov8" title="1">{
        // Simple HTML tag removal - for production use, consider using a proper HTML parser
        result := content
        result = strings.ReplaceAll(result, "&lt;br&gt;", "\n")
        result = strings.ReplaceAll(result, "&lt;br/&gt;", "\n")
        result = strings.ReplaceAll(result, "&lt;br /&gt;", "\n")
        result = strings.ReplaceAll(result, "&lt;/p&gt;", "\n")

        // Remove all other HTML tags (simple regex would be better)
        for strings.Contains(result, "&lt;") &amp;&amp; strings.Contains(result, "&gt;") </span><span class="cov8" title="1">{
                start := strings.Index(result, "&lt;")
                end := strings.Index(result[start:], "&gt;")
                if end == -1 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">result = result[:start] + result[start+end+1:]</span>
        }

        <span class="cov8" title="1">return strings.TrimSpace(result)</span>
}

// PrunePosts deletes posts according to specified criteria
func (c *MastodonClient) PrunePosts(username string, options PruneOptions) (*PruneResult, error) <span class="cov8" title="1">{
        // Get authentication credentials
        creds, err := GetCredentialsForPlatform("mastodon")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication required: %w", err)
        }</span>

        <span class="cov8" title="1">if err := ValidateCredentials(creds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid credentials: %w", err)
        }</span>

        // Parse username to get instance URL
        <span class="cov8" title="1">instanceURL, _, err := c.parseUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid username format: %w", err)
        }</span>

        // Fetch user's posts (we'd need to fetch more than 10 for real pruning)
        <span class="cov8" title="1">posts, err := c.FetchUserPosts(username, 100) // Fetch more posts for pruning
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch posts: %w", err)
        }</span>

        // If user wants to unlike posts, also fetch their favorited posts
        <span class="cov8" title="1">if options.UnlikePosts </span><span class="cov0" title="0">{
                favoriteIDs, err := c.fetchFavoriteIDs(instanceURL, creds, 100)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Warning: Failed to fetch favorited posts: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        // Convert favorite IDs to Post structs for processing
                        for _, favoriteID := range favoriteIDs </span><span class="cov0" title="0">{
                                favoritePost := Post{
                                        ID:        favoriteID,
                                        Type:      PostTypeLike,
                                        Platform:  "mastodon",
                                        CreatedAt: time.Now(), // We don't have the actual favorite time
                                        Content:   fmt.Sprintf("Favorited status: %s", favoriteID),
                                }
                                posts = append(posts, favoritePost)
                        }</span>
                }
        }

        <span class="cov8" title="1">result := &amp;PruneResult{
                PostsToDelete:  []Post{},
                PostsToUnlike:  []Post{},
                PostsToUnshare: []Post{},
                PostsPreserved: []Post{},
                Errors:         []string{},
        }

        now := time.Now()

        for _, post := range posts </span><span class="cov8" title="1">{
                shouldProcess := false
                preserveReason := ""

                // Check age criteria
                if options.MaxAge != nil </span><span class="cov8" title="1">{
                        if now.Sub(post.CreatedAt) &gt; *options.MaxAge </span><span class="cov8" title="1">{
                                shouldProcess = true
                        }</span>
                }

                // Check date criteria
                <span class="cov8" title="1">if options.BeforeDate != nil </span><span class="cov0" title="0">{
                        if post.CreatedAt.Before(*options.BeforeDate) </span><span class="cov0" title="0">{
                                shouldProcess = true
                        }</span>
                }

                <span class="cov8" title="1">if !shouldProcess </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check preservation rules
                <span class="cov8" title="1">if options.PreservePinned &amp;&amp; post.IsPinned </span><span class="cov0" title="0">{
                        preserveReason = "pinned"
                }</span> else<span class="cov8" title="1"> if options.PreserveSelfLike &amp;&amp; post.IsLikedByUser &amp;&amp; post.Type == PostTypeOriginal </span><span class="cov0" title="0">{
                        preserveReason = "self-liked"
                }</span>

                <span class="cov8" title="1">if preserveReason != "" </span><span class="cov0" title="0">{
                        result.PostsPreserved = append(result.PostsPreserved, post)
                        result.PreservedCount++
                }</span> else<span class="cov8" title="1"> {
                        // Determine action based on post type
                        if post.Type == PostTypeLike </span><span class="cov0" title="0">{
                                // Handle favorite records - unfavorite them
                                result.PostsToUnlike = append(result.PostsToUnlike, post)
                                if !options.DryRun </span><span class="cov0" title="0">{
                                        // Add configurable delay to respect rate limits
                                        time.Sleep(options.RateLimitDelay)
                                        logger := WithPlatform("mastodon").With().Str("post_id", post.ID).Logger()
                                        if err := c.unlikePost(creds, post.ID); err != nil </span><span class="cov0" title="0">{
                                                logger.Error().Err(err).Msg("Failed to unfavorite post")
                                                fmt.Printf("‚ùå Failed to unfavorite post: %v\n", err)
                                                result.Errors = append(result.Errors, fmt.Sprintf("Failed to unfavorite post %s: %v", post.ID, err))
                                                result.ErrorsCount++
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Info().Str("content", TruncateContent(post.Content, 50)).Msg("Post unfavorited successfully")
                                                fmt.Printf("üëç Unfavorited post: %s\n", TruncateContent(post.Content, 50))
                                                result.UnlikedCount++
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> if post.Type == PostTypeRepost </span><span class="cov0" title="0">{
                                // Always unreblog for reblog records - these are the user's own reblog actions
                                result.PostsToUnshare = append(result.PostsToUnshare, post)
                                if !options.DryRun </span><span class="cov0" title="0">{
                                        // Add configurable delay to respect rate limits
                                        time.Sleep(options.RateLimitDelay)
                                        logger := WithPlatform("mastodon").With().Str("post_id", post.ID).Logger()
                                        if err := c.unreblogPost(creds, post.ID); err != nil </span><span class="cov0" title="0">{
                                                logger.Error().Err(err).Msg("Failed to unreblog post")
                                                fmt.Printf("‚ùå Failed to unreblog post from %s: %v\n", post.CreatedAt.Format("2006-01-02"), err)
                                                result.Errors = append(result.Errors, fmt.Sprintf("Failed to unreblog post %s: %v", post.ID, err))
                                                result.ErrorsCount++
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Info().Str("content", TruncateContent(post.Content, 50)).Msg("Reblog unshared successfully")
                                                fmt.Printf("üîÑ Unshared reblog from %s: %s\n", post.CreatedAt.Format("2006-01-02"), TruncateContent(post.Content, 50))
                                                result.UnsharedCount++
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> if post.Type == PostTypeOriginal || post.Type == PostTypeReply </span><span class="cov8" title="1">{
                                // Only delete the user's own original posts and replies
                                result.PostsToDelete = append(result.PostsToDelete, post)
                                if !options.DryRun </span><span class="cov0" title="0">{
                                        // Add configurable delay to respect rate limits
                                        time.Sleep(options.RateLimitDelay)
                                        logger := WithPlatform("mastodon").With().Str("post_id", post.ID).Logger()
                                        if err := c.deletePost(creds, post.ID); err != nil </span><span class="cov0" title="0">{
                                                logger.Error().Err(err).Msg("Failed to delete post")
                                                fmt.Printf("‚ùå Failed to delete post from %s: %v\n", post.CreatedAt.Format("2006-01-02"), err)
                                                result.Errors = append(result.Errors, fmt.Sprintf("Failed to delete post %s: %v", post.ID, err))
                                                result.ErrorsCount++
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Info().Str("content", TruncateContent(post.Content, 50)).Msg("Post deleted successfully")
                                                fmt.Printf("üóëÔ∏è  Deleted post from %s: %s\n", post.CreatedAt.Format("2006-01-02"), TruncateContent(post.Content, 50))
                                                result.DeletedCount++
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// deletePost deletes a Mastodon post
func (c *MastodonClient) deletePost(creds *Credentials, postID string) error <span class="cov0" title="0">{
        c.ensureAuthenticated(creds, creds.Instance)
        url := fmt.Sprintf("%s/api/v1/statuses/%s", creds.Instance, postID)

        req, err := c.authenticatedClient.CreateRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.authenticatedClient.DoRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// unlikePost unlikes (unfavourites) a Mastodon post
func (c *MastodonClient) unlikePost(creds *Credentials, postID string) error <span class="cov0" title="0">{
        c.ensureAuthenticated(creds, creds.Instance)
        url := fmt.Sprintf("%s/api/v1/statuses/%s/unfavourite", creds.Instance, postID)

        req, err := c.authenticatedClient.CreateRequest("POST", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.authenticatedClient.DoRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// unreblogPost unreblogs (unshares) a Mastodon post
func (c *MastodonClient) unreblogPost(creds *Credentials, postID string) error <span class="cov0" title="0">{
        c.ensureAuthenticated(creds, creds.Instance)
        url := fmt.Sprintf("%s/api/v1/statuses/%s/unreblog", creds.Instance, postID)

        req, err := c.authenticatedClient.CreateRequest("POST", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.authenticatedClient.DoRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// determinePostType determines the type of Mastodon post
func (c *MastodonClient) determinePostType(status mastodonStatus) PostType <span class="cov8" title="1">{
        if status.Reblog != nil </span><span class="cov8" title="1">{
                return PostTypeRepost
        }</span>
        <span class="cov8" title="1">if status.InReplyToID != nil </span><span class="cov8" title="1">{
                return PostTypeReply
        }</span>
        <span class="cov8" title="1">return PostTypeOriginal</span>
}

// ensureAuthenticated ensures we have cached authentication details
func (c *MastodonClient) ensureAuthenticated(creds *Credentials, instanceURL string) <span class="cov0" title="0">{
        // Cache credentials and instance URL for reuse
        logger := WithPlatform("mastodon")
        if c.sessionManager.HasCredentialsChanged(creds) || c.instanceURL != instanceURL </span><span class="cov0" title="0">{
                if c.sessionManager.HasCredentialsChanged(creds) </span><span class="cov0" title="0">{
                        logger.Debug().Str("instance", instanceURL).Msg("Setting up Mastodon authentication")
                        fmt.Printf("üîê Setting up Mastodon authentication for %s...\n", instanceURL)
                }</span>
                <span class="cov0" title="0">c.sessionManager.UpdateSession(creds.AccessToken, "", time.Now().Add(24*time.Hour), creds)
                c.authenticatedClient = NewAuthenticatedHTTPClient(creds.AccessToken, instanceURL, 30*time.Second)
                c.instanceURL = instanceURL</span>
        }
}


// fetchFavoriteIDs fetches IDs of posts that the user has favorited
func (c *MastodonClient) fetchFavoriteIDs(instanceURL string, creds *Credentials, limit int) ([]string, error) <span class="cov0" title="0">{
        c.ensureAuthenticated(creds, instanceURL)
        favoritesURL := fmt.Sprintf("%s/api/v1/favourites", instanceURL)

        params := url.Values{}
        params.Add("limit", strconv.Itoa(limit))

        fullURL := fmt.Sprintf("%s?%s", favoritesURL, params.Encode())

        req, err := c.authenticatedClient.CreateRequest("GET", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.authenticatedClient.DoRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">var statuses []mastodonStatus
        if err := json.Unmarshal(body, &amp;statuses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">var favoriteIDs []string
        for _, status := range statuses </span><span class="cov0" title="0">{
                favoriteIDs = append(favoriteIDs, status.ID)
        }</span>

        <span class="cov0" title="0">return favoriteIDs, nil</span>
}

</pre>
		
		<pre class="file" id="file12" style="display: none">package internal

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"
)

// PostType represents the type of social media post
type PostType string

const (
        PostTypeOriginal PostType = "original" // User's own original content
        PostTypeRepost   PostType = "repost"   // Retweet/Reblog/Repost of another user's content
        PostTypeReply    PostType = "reply"    // Reply to another post
        PostTypeLike     PostType = "like"     // Like/Favorite (if platform shows these in timeline)
        PostTypeQuote    PostType = "quote"    // Quote post/retweet with comment
)

// Post represents a generic social media post
type Post struct {
        ID        string    `json:"id"`
        Author    string    `json:"author"`        // Display name of the post author
        Handle    string    `json:"handle"`        // Username/handle of the post author
        Content   string    `json:"content"`       // Text content of the post
        CreatedAt time.Time `json:"created_at"`    // When the post was created
        URL       string    `json:"url,omitempty"` // Direct URL to the post

        // Post type and interaction metadata
        Type PostType `json:"type"` // Type of post (original, repost, reply, etc.)

        // Original post information (for reposts/quotes)
        OriginalPost   *Post  `json:"original_post,omitempty"`   // The original post being shared
        OriginalAuthor string `json:"original_author,omitempty"` // Display name of original author
        OriginalHandle string `json:"original_handle,omitempty"` // Handle of original author

        // Reply metadata
        InReplyToID     string `json:"in_reply_to_id,omitempty"`     // ID of post being replied to
        InReplyToAuthor string `json:"in_reply_to_author,omitempty"` // Author of post being replied to

        // Engagement metrics
        RepostCount int `json:"repost_count,omitempty"` // Number of reposts/retweets
        LikeCount   int `json:"like_count,omitempty"`   // Number of likes/favorites
        ReplyCount  int `json:"reply_count,omitempty"`  // Number of replies

        // Post status flags
        IsLikedByUser bool `json:"is_liked_by_user,omitempty"` // Whether the viewing user has liked this post
        IsPinned      bool `json:"is_pinned,omitempty"`        // Whether this post is pinned by the author

        // Platform-specific metadata
        Platform string                 `json:"platform"`           // Which platform this post is from
        RawData  map[string]interface{} `json:"raw_data,omitempty"` // Platform-specific raw data
}

// PruneOptions defines criteria for pruning posts
type PruneOptions struct {
        MaxAge           *time.Duration `json:"max_age,omitempty"`     // Delete posts older than this duration
        BeforeDate       *time.Time     `json:"before_date,omitempty"` // Delete posts created before this date
        PreserveSelfLike bool           `json:"preserve_self_like"`    // Don't delete user's own posts they've liked
        PreservePinned   bool           `json:"preserve_pinned"`       // Don't delete pinned posts
        UnlikePosts      bool           `json:"unlike_posts"`          // Unlike posts instead of deleting them
        UnshareReposts   bool           `json:"unshare_reposts"`       // Unshare/unrepost instead of deleting reposts
        DryRun           bool           `json:"dry_run"`               // Only show what would be deleted
        RateLimitDelay   time.Duration  `json:"rate_limit_delay"`      // Delay between API requests to respect rate limits
}

// PruneResult represents the result of a pruning operation
type PruneResult struct {
        PostsToDelete  []Post   `json:"posts_to_delete"`
        PostsToUnlike  []Post   `json:"posts_to_unlike"`
        PostsToUnshare []Post   `json:"posts_to_unshare"`
        PostsPreserved []Post   `json:"posts_preserved"`
        DeletedCount   int      `json:"deleted_count"`
        UnlikedCount   int      `json:"unliked_count"`
        UnsharedCount  int      `json:"unshared_count"`
        PreservedCount int      `json:"preserved_count"`
        ErrorsCount    int      `json:"errors_count"`
        Errors         []string `json:"errors,omitempty"`
}

// SocialClient defines the interface for social media platforms
type SocialClient interface {
        // FetchUserPosts retrieves recent posts for a given username
        FetchUserPosts(username string, limit int) ([]Post, error)

        // FetchUserPostsPaginated retrieves posts with pagination support
        FetchUserPostsPaginated(username string, limit int, cursor string) ([]Post, string, error)

        // GetPlatformName returns the name of the social platform
        GetPlatformName() string

        // PrunePosts deletes posts according to specified criteria
        PrunePosts(username string, options PruneOptions) (*PruneResult, error)

        // RequiresAuth returns true if the platform requires authentication for deletion
        RequiresAuth() bool
}

// SupportedPlatforms maps platform names to their client constructors
var SupportedPlatforms = map[string]func() SocialClient{
        "bluesky":  func() SocialClient <span class="cov8" title="1">{ return NewBlueskyClient() }</span>,
        "mastodon": func() SocialClient <span class="cov8" title="1">{ return NewMastodonClient() }</span>,
}

// GetClient returns a social client for the specified platform
func GetClient(platform string) (SocialClient, bool) <span class="cov8" title="1">{
        constructor, exists := SupportedPlatforms[platform]
        if !exists </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov8" title="1">return constructor(), true</span>
}

// GetAllPlatformNames returns a slice of all supported platform names
func GetAllPlatformNames() []string <span class="cov0" title="0">{
        platforms := make([]string, 0, len(SupportedPlatforms))
        for platform := range SupportedPlatforms </span><span class="cov0" title="0">{
                platforms = append(platforms, platform)
        }</span>
        <span class="cov0" title="0">return platforms</span>
}

// ParsePlatforms parses a comma-separated list of platforms and validates them
func ParsePlatforms(platformsStr string) ([]string, error) <span class="cov0" title="0">{
        if platformsStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("platforms cannot be empty")
        }</span>

        // Handle special case: "all" means all supported platforms
        <span class="cov0" title="0">if platformsStr == "all" </span><span class="cov0" title="0">{
                return GetAllPlatformNames(), nil
        }</span>

        // Split by comma and trim whitespace
        <span class="cov0" title="0">platformList := strings.Split(platformsStr, ",")
        validPlatforms := make([]string, 0, len(platformList))
        
        for _, platform := range platformList </span><span class="cov0" title="0">{
                platform = strings.TrimSpace(platform)
                if platform == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Validate platform exists
                <span class="cov0" title="0">if _, exists := SupportedPlatforms[platform]; !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unsupported platform '%s'. Supported platforms: %s", 
                                platform, strings.Join(GetAllPlatformNames(), ", "))
                }</span>
                
                // Avoid duplicates
                <span class="cov0" title="0">found := false
                for _, existing := range validPlatforms </span><span class="cov0" title="0">{
                        if existing == platform </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        validPlatforms = append(validPlatforms, platform)
                }</span>
        }
        
        <span class="cov0" title="0">if len(validPlatforms) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid platforms specified")
        }</span>
        
        <span class="cov0" title="0">return validPlatforms, nil</span>
}

// HTTPClientConfig holds configuration for HTTP clients
type HTTPClientConfig struct {
        Timeout time.Duration
}

// CreateHTTPClient creates a standardized HTTP client with proper timeouts
func CreateHTTPClient(config HTTPClientConfig) *http.Client <span class="cov0" title="0">{
        if config.Timeout == 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">return &amp;http.Client{
                Timeout: config.Timeout,
        }</span>
}

// SessionManager provides common session management functionality
type SessionManager struct {
        credentials   *Credentials
        accessToken   string
        refreshToken  string
        sessionExpiry time.Time
        platform      string
}

// NewSessionManager creates a new session manager
func NewSessionManager(platform string) *SessionManager <span class="cov8" title="1">{
        return &amp;SessionManager{
                platform: platform,
        }
}</span>

// IsSessionValid checks if the current session is still valid
func (sm *SessionManager) IsSessionValid() bool <span class="cov0" title="0">{
        return sm.accessToken != "" &amp;&amp; time.Now().Before(sm.sessionExpiry.Add(-5*time.Minute))
}</span>

// HasCredentialsChanged checks if credentials have changed from the cached ones
func (sm *SessionManager) HasCredentialsChanged(creds *Credentials) bool <span class="cov8" title="1">{
        if sm.credentials == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        
        <span class="cov0" title="0">switch sm.platform </span>{
        case "bluesky":<span class="cov0" title="0">
                return sm.credentials.Username != creds.Username || sm.credentials.AppPassword != creds.AppPassword</span>
        case "mastodon":<span class="cov0" title="0">
                return sm.credentials.AccessToken != creds.AccessToken || sm.credentials.Instance != creds.Instance</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// UpdateSession updates the session with new tokens and expiry
func (sm *SessionManager) UpdateSession(accessToken, refreshToken string, expiry time.Time, creds *Credentials) <span class="cov8" title="1">{
        sm.accessToken = accessToken
        sm.refreshToken = refreshToken
        sm.sessionExpiry = expiry
        sm.credentials = &amp;Credentials{
                Username:    creds.Username,
                AppPassword: creds.AppPassword,
                AccessToken: creds.AccessToken,
                Instance:    creds.Instance,
        }
}</span>

// GetAccessToken returns the current access token
func (sm *SessionManager) GetAccessToken() string <span class="cov0" title="0">{
        return sm.accessToken
}</span>

// GetRefreshToken returns the current refresh token
func (sm *SessionManager) GetRefreshToken() string <span class="cov0" title="0">{
        return sm.refreshToken
}</span>

// ClearSession clears the current session
func (sm *SessionManager) ClearSession() <span class="cov0" title="0">{
        sm.credentials = nil
        sm.accessToken = ""
        sm.refreshToken = ""
        sm.sessionExpiry = time.Time{}
}</span>

// AuthenticatedHTTPClient provides common authenticated HTTP request functionality
type AuthenticatedHTTPClient struct {
        client      *http.Client
        accessToken string
        baseURL     string
}

// NewAuthenticatedHTTPClient creates a new authenticated HTTP client
func NewAuthenticatedHTTPClient(accessToken, baseURL string, timeout time.Duration) *AuthenticatedHTTPClient <span class="cov0" title="0">{
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 30 * time.Second
        }</span>
        
        <span class="cov0" title="0">return &amp;AuthenticatedHTTPClient{
                client:      &amp;http.Client{Timeout: timeout},
                accessToken: accessToken,
                baseURL:     baseURL,
        }</span>
}

// CreateRequest creates an HTTP request with authentication headers
func (ahc *AuthenticatedHTTPClient) CreateRequest(method, path string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var url string
        if strings.HasPrefix(path, "http") </span><span class="cov0" title="0">{
                url = path
        }</span> else<span class="cov0" title="0"> {
                url = ahc.baseURL + path
        }</span>
        
        <span class="cov0" title="0">req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">if ahc.accessToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+ahc.accessToken)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        
        return req, nil</span>
}

// DoRequest executes an HTTP request and returns the response
func (ahc *AuthenticatedHTTPClient) DoRequest(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        LogHTTPRequest(req.Method, req.URL.String())
        
        resp, err := ahc.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logger := WithHTTP(req.Method, req.URL.String())
                logger.Error().Err(err).Msg("HTTP request failed")
                return nil, err
        }</span>
        
        <span class="cov0" title="0">LogHTTPResponse(req.Method, req.URL.String(), resp.StatusCode, resp.Status)
        
        return resp, nil</span>
}

// ParseErrorResponse extracts error information from HTTP response
func ParseErrorResponse(resp *http.Response) error <span class="cov0" title="0">{
        body, _ := io.ReadAll(resp.Body)
        err := fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
        
        logger := WithHTTP("RESPONSE", resp.Request.URL.String())
        logger.Error().
                Int("status_code", resp.StatusCode).
                Str("response_body", string(body)).
                Msg("API request failed")
        
        return err
}</span>

// TruncateContent truncates content for display in progress messages
func TruncateContent(content string, maxLen int) string <span class="cov8" title="1">{
        // Replace newlines with spaces for display
        content = strings.ReplaceAll(content, "\n", " ")
        if len(content) &lt;= maxLen </span><span class="cov8" title="1">{
                return content
        }</span>
        <span class="cov8" title="1">if maxLen &lt;= 3 </span><span class="cov8" title="1">{
                return "..."
        }</span>
        <span class="cov8" title="1">return content[:maxLen-3] + "..."</span>
}

// RateLimiter provides common rate limiting functionality
type RateLimiter struct {
        delay time.Duration
}

// NewRateLimiter creates a new rate limiter with the specified delay
func NewRateLimiter(delay time.Duration) *RateLimiter <span class="cov0" title="0">{
        return &amp;RateLimiter{delay: delay}
}</span>

// Wait sleeps for the configured delay
func (rl *RateLimiter) Wait() <span class="cov0" title="0">{
        if rl.delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(rl.delay)
        }</span>
}

// APIListRequest represents a common pattern for paginated list requests
type APIListRequest struct {
        URL        string
        Params     url.Values
        Limit      int
        Collection string // For AT Protocol
        Repo       string // For AT Protocol
}

// ExecuteListRequest executes a paginated list request and returns the response body
func ExecuteListRequest(client *AuthenticatedHTTPClient, request APIListRequest) ([]byte, error) <span class="cov0" title="0">{
        logger := WithOperation("list_request")
        logger.Debug().
                Str("url", request.URL).
                Int("limit", request.Limit).
                Str("collection", request.Collection).
                Str("repo", request.Repo).
                Msg("Executing list request")
        
        params := url.Values{}
        for k, v := range request.Params </span><span class="cov0" title="0">{
                params[k] = v
        }</span>
        
        <span class="cov0" title="0">if request.Limit &gt; 0 </span><span class="cov0" title="0">{
                params.Add("limit", fmt.Sprintf("%d", request.Limit))
        }</span>
        
        <span class="cov0" title="0">if request.Collection != "" </span><span class="cov0" title="0">{
                params.Add("collection", request.Collection)
        }</span>
        
        <span class="cov0" title="0">if request.Repo != "" </span><span class="cov0" title="0">{
                params.Add("repo", request.Repo)
        }</span>
        
        <span class="cov0" title="0">fullURL := request.URL
        if len(params) &gt; 0 </span><span class="cov0" title="0">{
                fullURL += "?" + params.Encode()
        }</span>
        
        <span class="cov0" title="0">req, err := client.CreateRequest("GET", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("Failed to create list request")
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        
        <span class="cov0" title="0">resp, err := client.DoRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("List request failed")
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, ParseErrorResponse(resp)
        }</span>
        
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("Failed to read list response body")
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>
        
        <span class="cov0" title="0">logger.Debug().
                Int("response_size", len(body)).
                Msg("List request completed successfully")
        
        return body, nil</span>
}

// DeleteRecordRequest represents a common delete record request
type DeleteRecordRequest struct {
        Repo       string
        Collection string
        RKey       string
}

// ExecuteDeleteRequest executes a delete record request
func ExecuteDeleteRequest(client *AuthenticatedHTTPClient, deleteURL string, request DeleteRecordRequest) error <span class="cov0" title="0">{
        logger := WithOperation("delete_request")
        logger.Info().
                Str("repo", request.Repo).
                Str("collection", request.Collection).
                Str("rkey", request.RKey).
                Msg("Executing delete request")
        
        deleteData := map[string]string{
                "repo":       request.Repo,
                "collection": request.Collection,
                "rkey":       request.RKey,
        }
        
        jsonData, err := json.Marshal(deleteData)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("Failed to marshal delete data")
                return fmt.Errorf("failed to marshal delete data: %w", err)
        }</span>
        
        <span class="cov0" title="0">req, err := client.CreateRequest("POST", deleteURL, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("Failed to create delete request")
                return fmt.Errorf("failed to create delete request: %w", err)
        }</span>
        
        <span class="cov0" title="0">resp, err := client.DoRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("Delete request failed")
                return fmt.Errorf("delete request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return ParseErrorResponse(resp)
        }</span>
        
        <span class="cov0" title="0">logger.Info().Msg("Delete request completed successfully")
        return nil</span>
}

// ExtractPostIDFromURI extracts the post ID from a URI
func ExtractPostIDFromURI(uri string) string <span class="cov0" title="0">{
        if len(uri) &gt; 0 </span><span class="cov0" title="0">{
                parts := []rune(uri)
                for i := len(parts) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        if parts[i] == '/' </span><span class="cov0" title="0">{
                                return string(parts[i+1:])
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// ValidateURIOwnership validates that a URI belongs to the specified owner DID/ID
func ValidateURIOwnership(uri, ownerID string) error <span class="cov0" title="0">{
        parts := strings.Split(uri, "/")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid URI format: %s", uri)
        }</span>
        
        <span class="cov0" title="0">uriOwner := parts[2]
        if uriOwner != ownerID </span><span class="cov0" title="0">{
                return fmt.Errorf("URI owner %s does not match expected owner %s", uriOwner, ownerID)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package internal

import (
        "runtime/debug"
        "strings"
)

// Version information
var (
        // Version is set by build-time flags or git tags
        Version = "dev"
        // Commit is set by build-time flags  
        Commit = "unknown"
        // BuildTime is set by build-time flags
        BuildTime = "unknown"
)

// GetVersion returns the current version information
func GetVersion() string <span class="cov0" title="0">{
        if Version != "dev" </span><span class="cov0" title="0">{
                return Version
        }</span>
        
        // Try to get version from build info (when built with go install)
        <span class="cov0" title="0">if info, ok := debug.ReadBuildInfo(); ok </span><span class="cov0" title="0">{
                // Look for version in build info
                for _, setting := range info.Settings </span><span class="cov0" title="0">{
                        if setting.Key == "vcs.tag" &amp;&amp; setting.Value != "" </span><span class="cov0" title="0">{
                                // Clean up git tag (remove 'v' prefix if present)
                                version := strings.TrimPrefix(setting.Value, "v")
                                if version != "" </span><span class="cov0" title="0">{
                                        return version
                                }</span>
                        }
                }
                
                // Fallback to revision if available
                <span class="cov0" title="0">for _, setting := range info.Settings </span><span class="cov0" title="0">{
                        if setting.Key == "vcs.revision" &amp;&amp; setting.Value != "" </span><span class="cov0" title="0">{
                                return "dev-" + setting.Value[:8]
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return "dev"</span>
}

// GetFullVersionInfo returns detailed version information
func GetFullVersionInfo() map[string]string <span class="cov0" title="0">{
        version := GetVersion()
        commit := Commit
        buildTime := BuildTime
        
        // Try to get additional info from build info
        if info, ok := debug.ReadBuildInfo(); ok </span><span class="cov0" title="0">{
                for _, setting := range info.Settings </span><span class="cov0" title="0">{
                        switch setting.Key </span>{
                        case "vcs.revision":<span class="cov0" title="0">
                                if commit == "unknown" &amp;&amp; setting.Value != "" </span><span class="cov0" title="0">{
                                        commit = setting.Value[:8]
                                }</span>
                        case "vcs.time":<span class="cov0" title="0">
                                if buildTime == "unknown" &amp;&amp; setting.Value != "" </span><span class="cov0" title="0">{
                                        buildTime = setting.Value
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return map[string]string{
                "version":    version,
                "commit":     commit,
                "build_time": buildTime,
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
